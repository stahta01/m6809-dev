From aaef7a86f718d6104b799eff06b315cffdbc3d4a Mon Sep 17 00:00:00 2001
From: Tim S <stahta01@users.sourceforge.net>
Date: Thu, 15 Nov 2018 21:28:13 -0500
Subject: [PATCH 2/5] gcc6809: Add files from gcc6809 as-5.1.1 folder

---
 asxv5pxx/as6309/m09adr.c              |  295 ++++++++
 asxv5pxx/as6309/m09mch.c              |  661 ++++++++++++++++
 asxv5pxx/as6309/m09pst.c              |  597 +++++++++++++++
 asxv5pxx/as6309/m6809.h               |  183 +++++
 asxv5pxx/as6309/t6309.asm             |    9 +
 asxv5pxx/as6809/m09mch.c              |    6 +
 asxv5pxx/as6809/m09pst.c              |   16 +
 asxv5pxx/as6809/m6809.h               |    4 +
 asxv5pxx/asxmak/cygwin/build/makefile |   27 +-
 asxv5pxx/asxmak/darwin/build/makefile | 1000 +++++++++++++++++++++++++
 asxv5pxx/asxmak/djgpp/build/makefile  |   27 +-
 asxv5pxx/asxmak/linux/build/makefile  |   33 +-
 asxv5pxx/asxxmisc/asxxconv.c          |   18 +-
 asxv5pxx/asxxmisc/asxxscan.c          |   20 +-
 asxv5pxx/asxxsrc/asdata.c             |    2 +-
 asxv5pxx/asxxsrc/asexpr.c             |    2 +-
 asxv5pxx/asxxsrc/aslex.c              |    3 +
 asxv5pxx/asxxsrc/aslist.c             |   18 +-
 asxv5pxx/asxxsrc/asmain.c             |   11 +-
 asxv5pxx/asxxsrc/asout.c              |   58 +-
 asxv5pxx/asxxsrc/asxxxx.h             |   37 +-
 asxv5pxx/change.txt                   |  312 ++++----
 asxv5pxx/config.h                     |   19 +
 asxv5pxx/home.htm                     |    8 +
 asxv5pxx/libsrc/ardata.c              |   55 ++
 asxv5pxx/libsrc/armain.c              |  493 ++++++++++++
 asxv5pxx/libsrc/aslib.h               |   56 ++
 asxv5pxx/libsrc/common.c              |  200 +++++
 asxv5pxx/libsrc/nmmain.c              |  133 ++++
 asxv5pxx/linksrc/aslink.h             |   73 +-
 asxv5pxx/linksrc/lkarea.c             |   48 +-
 asxv5pxx/linksrc/lkbank.c             |   41 +-
 asxv5pxx/linksrc/lkdata.c             |   15 +-
 asxv5pxx/linksrc/lkeval.c             |   12 +-
 asxv5pxx/linksrc/lkhead.c             |   11 +-
 asxv5pxx/linksrc/lklex.c              |   23 +-
 asxv5pxx/linksrc/lklibr.c             |  874 ++++++++++++++++-----
 asxv5pxx/linksrc/lklist.c             |   26 +-
 asxv5pxx/linksrc/lkmain.c             |  138 +++-
 asxv5pxx/linksrc/lknoice.c            |    7 +-
 asxv5pxx/linksrc/lkrloc.c             |    3 +-
 asxv5pxx/linksrc/lkrloc3.c            |   53 +-
 asxv5pxx/linksrc/lkrloc4.c            |   56 +-
 asxv5pxx/linksrc/lksdcdb.c            |   56 +-
 asxv5pxx/linksrc/lksym.c              |   98 ++-
 asxv5pxx/readme.txt                   |    8 +-
 46 files changed, 5126 insertions(+), 719 deletions(-)
 create mode 100644 asxv5pxx/as6309/m09adr.c
 create mode 100644 asxv5pxx/as6309/m09mch.c
 create mode 100644 asxv5pxx/as6309/m09pst.c
 create mode 100644 asxv5pxx/as6309/m6809.h
 create mode 100644 asxv5pxx/as6309/t6309.asm
 create mode 100644 asxv5pxx/asxmak/darwin/build/makefile
 create mode 100644 asxv5pxx/config.h
 create mode 100644 asxv5pxx/home.htm
 create mode 100644 asxv5pxx/libsrc/ardata.c
 create mode 100644 asxv5pxx/libsrc/armain.c
 create mode 100644 asxv5pxx/libsrc/aslib.h
 create mode 100644 asxv5pxx/libsrc/common.c
 create mode 100644 asxv5pxx/libsrc/nmmain.c

diff --git a/asxv5pxx/as6309/m09adr.c b/asxv5pxx/as6309/m09adr.c
new file mode 100644
index 0000000..ca76701
--- /dev/null
+++ b/asxv5pxx/as6309/m09adr.c
@@ -0,0 +1,295 @@
+/* M09ADR.C */
+
+/*
+ *  Copyright (C) 1989-2014  Alan R. Baldwin
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ * Alan R. Baldwin
+ * 721 Berkeley St.
+ * Kent, Ohio  44240
+ */
+
+#include "asxxxx.h"
+#include "m6809.h"
+
+int aindx;
+
+int
+addr(esp)
+struct expr *esp;
+{
+	int c;
+
+	aindx = 0;
+	if ((c = getnb()) == '#') {
+		expr(esp, 0);
+		esp->e_mode = S_IMMED;
+	} else
+	if (c == '[') {
+		aindx = 0x90;
+		addr1(esp);
+		if (getnb() != ']') {
+			aerr();
+		}
+	} else {
+		unget(c);
+		addr1(esp);
+	}
+	return (esp->e_mode);
+}
+
+int
+addr1(esp)
+struct expr *esp;
+{
+	int c;
+
+	if (admode(abd)) {
+		comma(1);
+		if (!admode(xyus))
+			aerr();
+		esp->e_mode = S_IND;
+	} else
+	if ((c = getnb()) == ',') {
+		if (admode(xyus)) {
+			aindx |= 0x04;
+		} else
+		if (admode(auto2)) {
+			;
+		} else
+		if (!(aindx & 0x10) && admode(auto1)) {
+			;
+		} else {
+			aerr();
+		}
+		esp->e_mode = S_IND;
+	} else
+	if (c == '*') {
+		expr(esp, 0);
+		esp->e_mode = S_DIR;
+		if (comma(0)) {
+			if (admode(xyus)) {
+				esp->e_mode = S_OFST;
+			} else
+			if (admode(pcr)) {
+				esp->e_mode = S_PCR;
+			} else
+			if (admode(pc)) {
+				esp->e_mode = S_PC;
+			} else {
+				aerr();
+			}
+		}
+	} else {
+		unget(c);
+		expr(esp, 0);
+		if (comma(0)) {
+			if (admode(xyus)) {
+				esp->e_mode = S_OFST;
+			} else
+			if (admode(pcr)) {
+				esp->e_mode = S_PCR;
+			} else
+			if (admode(pc)) {
+				esp->e_mode = S_PC;
+			} else {
+				aerr();
+			}
+		} else {
+			esp->e_mode = S_EXT;
+		}
+	}
+	return (esp->e_mode);
+}
+
+	
+/*
+ * Enter admode() to search a specific addressing mode table
+ * for a match. Return the addressing value on a match or
+ * zero for no match.
+ */
+int
+admode(sp)
+struct adsym *sp;
+{
+	char *ptr;
+	int i, v;
+	char *ips;
+
+	ips = ip;
+	unget(getnb());
+
+	i = 0;
+	while ( *(ptr = &sp[i].a_str[0]) ) {
+		if (srch(ptr)) {
+			v = sp[i].a_val;
+			aindx |= (v | 0x80);
+			return(v);
+		}
+		i++;
+	}
+	ip = ips;
+	return(0);
+}
+
+/*
+ *      srch --- does string match ?
+ */
+int
+srch(str)
+char *str;
+{
+	char *ptr;
+	ptr = ip;
+
+	while (*ptr && *str) {
+		if (ccase[*ptr & 0x007F] != ccase[*str & 0x007F])
+			break;
+		ptr++;
+		str++;
+	}
+	if (ccase[*ptr & 0x007F] == ccase[*str & 0x007F]) {
+		ip = ptr;
+		return(1);
+	}
+
+	if (!*str)
+		if (any(*ptr," \t\n,];")) {
+			ip = ptr;
+			return(1);
+		}
+	return(0);
+}
+
+/*
+ *      any --- does str contain c?
+ */
+int
+any(c,str)
+int c;
+char *str;
+{
+	while (*str)
+		if(*str++ == c)
+			return(1);
+	return(0);
+}
+
+struct adsym	abd[] = {	/* a, b, or d indexed offset */
+    {	"a",	0x06	},
+    {	"b",	0x05	},
+    {	"d",	0x0B	},
+    {	"e",	0x07	},
+    {	"f",	0x0A	},
+    {	"w",	0x0E	},
+    {	"",	0x00	}
+};
+
+struct adsym	xyus[] = {	/* x, y, u, or s index register */
+    {	"x",	0x100	},
+    {	"y",	0x120	},
+    {	"u",	0x140	},
+    {	"s",	0x160	},
+    {	"",	0x000	}
+};
+
+struct adsym	auto1[] = {	/* auto increment/decrement by 1 */
+    {	"x+",	0x100	},
+    {	"-x",	0x102	},
+    {	"y+",	0x120	},
+    {	"-y",	0x122	},
+    {	"u+",	0x140	},
+    {	"-u",	0x142	},
+    {	"s+",	0x160	},
+    {	"-s",	0x162	},
+    {	"",	0x000	}
+};
+
+struct adsym	auto2[] = {	/* auto increment/decrement by 2 */
+    {	"x++",	0x101	},
+    {	"--x",	0x103	},
+    {	"y++",	0x121	},
+    {	"--y",	0x123	},
+    {	"u++",	0x141	},
+    {	"--u",	0x143	},
+    {	"s++",	0x161	},
+    {	"--s",	0x163	},
+    {	"",	0x000	}
+};
+
+struct adsym	pc[] = {	/* pc */
+    {	"pc",	0x0C	},
+    {	"",	0x00	}
+};
+
+struct adsym	pcr[] = {	/* pc relative */
+    {	"pcr",	0x0C	},
+    {	"",	0x00	}
+};
+
+struct adsym	regs[] = {	/* exg, tfr register coding */
+    {	"d",	0x100	},
+    {	"x",	0x101	},
+    {	"y",	0x102	},
+    {	"u",	0x103	},
+    {	"s",	0x104	},
+    {	"pc",	0x105	},
+    {	"w",	0x106	},
+    {	"v",	0x107	},
+    {	"a",	0x108	},
+    {	"b",	0x109	},
+    {	"cc",	0x10A	},
+    {	"dp",	0x10B	},
+    {	"0",	0x10C	},
+    {	"00",	0x10D	},
+    {	"e",	0x10E	},
+    {	"f",	0x10F	},
+    {	"",	0x000	}
+};
+
+struct adsym	stks[] = {	/* push/pull on system stack */
+    {	"cc",	0x01	},
+    {	"a",	0x02	},
+    {	"b",	0x04	},
+    {	"d",	0x06	},
+    {	"dp",	0x08	},
+    {	"x",	0x10	},
+    {	"y",	0x20	},
+    {	"u",	0x40	},
+    {	"pc",	0x80	},
+    {	"",	0x00	}
+};
+
+struct adsym	stku[] = {	/* push/pull on user stack */
+    {	"cc",	0x01	},
+    {	"a",	0x02	},
+    {	"b",	0x04	},
+    {	"d",	0x06	},
+    {	"dp",	0x08	},
+    {	"x",	0x10	},
+    {	"y",	0x20	},
+    {	"s",	0x40	},
+    {	"pc",	0x80	},
+    {	"",	0x00	}
+};
+
+struct adsym	bittr[] = {
+    {	"cc",	0x00	},
+    {	"a",	0x40	},
+    {	"b",	0x80	},
+    {	"",	0x00	}
+};
+
diff --git a/asxv5pxx/as6309/m09mch.c b/asxv5pxx/as6309/m09mch.c
new file mode 100644
index 0000000..17bc763
--- /dev/null
+++ b/asxv5pxx/as6309/m09mch.c
@@ -0,0 +1,661 @@
+/* M09MCH.C */
+
+/*
+ *  Copyright (C) 1989-2014  Alan R. Baldwin
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ * Alan R. Baldwin
+ * 721 Berkeley St.
+ * Kent, Ohio  44240
+ */
+
+#include "asxxxx.h"
+#include "m6809.h"
+
+char	*cpu	= "Hitachi 6309";
+char	*dsft	= "asm";
+
+#define	NB	512
+
+int	*bp;
+int	bm;
+int	bb[NB];
+
+/*
+ * Opcode Cycle Definitions
+ */
+#define	OPCY_SDP	((char) (0xFF))
+#define	OPCY_ERR	((char) (0xFE))
+
+/*	OPCY_NONE	((char) (0x80))	*/
+/*	OPCY_MASK	((char) (0x7F))	*/
+
+#define	OPCY_INDX	((char) (0x40))
+#define	OPCY_PSPL	((char) (0x20))
+
+#define	VALU_MASK	((char) (0x1F))
+
+#define	UN	((char) (OPCY_NONE | 0x00))
+#define	P2	((char) (OPCY_NONE | 0x01))
+#define	P3	((char) (OPCY_NONE | 0x02))
+
+#define	I3	((char) (OPCY_INDX | 0x03))
+#define	I4	((char) (OPCY_INDX | 0x04))
+#define	I5	((char) (OPCY_INDX | 0x05))
+#define	I6	((char) (OPCY_INDX | 0x06))
+#define	I7	((char) (OPCY_INDX | 0x07))
+
+#define	PP	((char) (OPCY_PSPL | 0x05))
+
+/*
+ * 6809 Cycle Count
+ *
+ *	opcycles = m09pg1[opcode]
+ */
+static char m09pg1[256] = {
+/*--*--* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
+/*--*--* -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - */
+/*00*/   6,UN,UN, 6, 6,UN, 6, 6, 6, 6, 6,UN, 6, 6, 3, 6,
+/*10*/  P2,P3, 2, 4,UN,UN, 5, 9,UN, 2, 3,UN, 3, 2, 8, 6,
+/*20*/   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+/*30*/  I4,I4,I4,I4,PP,PP,PP,PP,UN, 5, 3,15,20,11,UN,19,
+/*40*/   2,UN,UN, 2, 2,UN, 2, 2, 2, 2, 2,UN, 2, 2,UN, 2,
+/*50*/   2,UN,UN, 2, 2,UN, 2, 2, 2, 2, 2,UN, 2, 2,UN, 2,
+/*60*/  I6,UN,UN,I6,I6,UN,I6,I6,I6,I6,I6,UN,I6,I6,I3,I6,
+/*70*/   7,UN,UN, 7, 7,UN, 7, 7, 7, 7, 7,UN, 7, 7, 4, 7,
+/*80*/   2, 2, 2, 4, 2, 2, 2,UN, 2, 2, 2, 2, 4, 7, 3,UN,
+/*90*/   4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 6, 7, 5, 5,
+/*A0*/  I4,I4,I4,I6,I4,I4,I4,I4,I4,I4,I4,I4,I6,I7,I5,I5,
+/*B0*/   5, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 7, 8, 6, 6,
+/*C0*/   2, 2, 2, 4, 2, 2, 2,UN, 2, 2, 2, 2, 3,UN, 3,UN,
+/*D0*/   4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5,
+/*E0*/  I4,I4,I4,I6,I4,I4,I4,I4,I4,I4,I4,I4,I5,I5,I5,I5,
+/*F0*/   5, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6
+};
+
+static char m09pg2[256] = {
+/*--*--* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
+/*--*--* -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - */
+/*00*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*10*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*20*/  UN, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+/*30*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,20,
+/*40*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*50*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*60*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*70*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*80*/  UN,UN,UN, 5,UN,UN,UN,UN,UN,UN,UN,UN, 5,UN, 4,UN,
+/*90*/  UN,UN,UN, 7,UN,UN,UN,UN,UN,UN,UN,UN, 7,UN, 6,UN,
+/*A0*/  UN,UN,UN,I7,UN,UN,UN,UN,UN,UN,UN,UN,I7,UN,I6,I6,
+/*B0*/  UN,UN,UN, 8,UN,UN,UN,UN,UN,UN,UN,UN, 8,UN, 7, 7,
+/*C0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN, 4,UN,
+/*D0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN, 6, 6,
+/*E0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,I6,I6,
+/*F0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN, 7, 7
+};
+
+static char m09pg3[256] = {
+/*--*--* 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
+/*--*--* -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - */
+/*00*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*10*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*20*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*30*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,20,
+/*40*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*50*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*60*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*70*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*80*/  UN,UN,UN, 5,UN,UN,UN,UN,UN,UN,UN,UN, 5,UN,UN,UN,
+/*90*/  UN,UN,UN, 7,UN,UN,UN,UN,UN,UN,UN,UN, 7,UN,UN,UN,
+/*A0*/  UN,UN,UN,I7,UN,UN,UN,UN,UN,UN,UN,UN,I7,UN,UN,UN,
+/*B0*/  UN,UN,UN, 8,UN,UN,UN,UN,UN,UN,UN,UN, 8,UN,UN,UN,
+/*C0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*D0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*E0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,
+/*F0*/  UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN,UN
+};
+
+static char *Page[3] = {
+    m09pg1, m09pg2, m09pg3
+};
+
+static char m09idx[32] = {
+/*    ,R+	*/	2,	/*    ,R++	*/	3,
+/*    ,-R	*/	2,	/*    ,--R	*/	3,
+/*    ,R	*/	0,	/*   B,R	*/	1,
+/*   A,R	*/	1,	/*   ---	*/	0,
+/*   n,R     (8)*/	1,	/*   n,R    (16)*/	4,
+/*   ---	*/	0,	/*   D,R	*/	4,
+/*   n,PCR   (8)*/	1,	/*   n,PCR  (16)*/	5,
+/*   ---	*/	0,	/*   ---	*/	0,
+/*   ---	*/	0,	/*   [,R++]	*/	6,
+/*   ---	*/	0,	/*   [,--R]	*/	6,
+/*   [,R]	*/	3,	/*  [B,R]	*/	4,
+/*  [A,R]	*/	4,	/*   ---	*/	0,
+/*  [n,R]    (8)*/	4,	/*  [n,R]   (16)*/	7,
+/*   ---	*/	0,	/*  [D,R]	*/	7,
+/*  [n,PCR]  (8)*/	4,	/*  [n,PCR] (16)*/	8,
+/*   ---	*/	0,	/*  [n]		*/	5
+};
+
+#if	!M6809STRICT
+static char m00cyc[24] = {
+	12,12, 3, 3, 3, 5, 5, 5,
+	 5, 6, 6, 6, 6,12, 3, 3,
+	 3, 8, 6, 8, 6, 6, 6,20
+};
+#endif
+
+
+/*
+ * Process a machine op.
+ */
+VOID
+machine(mp)
+struct mne *mp;
+{
+	int op, rf, cpg, c;
+	struct expr e1;
+	int t1, v1, v2;
+	struct area *espa;
+	char id[NCPS];
+
+	cpg = 0;
+	clrexpr(&e1);
+	op = (int) mp->m_valu;
+	switch (rf = mp->m_type) {
+
+	case S_SDP:
+		opcycles = OPCY_SDP;
+		espa = NULL;
+		if (more()) {
+			expr(&e1, 0);
+			if (e1.e_flag == 0 && e1.e_base.e_ap == NULL) {
+				if (e1.e_addr & 0xFF) {
+					err('b');
+				}
+			}
+			if ((c = getnb()) == ',') {
+				getid(id, -1);
+				espa = alookup(id);
+				if (espa == NULL) {
+					err('u');
+				}
+			} else {
+				unget(c);
+			}
+		}
+		if (espa) {
+			outdp(espa, &e1, 0);
+		} else {
+			outdp(dot.s_area, &e1, 0);
+		}
+		lmode = SLIST;
+		break;
+
+	case S_INH2:
+		cpg += 0x01;
+
+	case S_INH1:
+		cpg += 0x10;
+
+	case S_INH:
+		if (cpg)
+			outab(cpg);
+		outab(op);
+		break;
+
+	case S_BRA:
+		expr(&e1, 0);
+		outab(op);
+		if (mchpcr(&e1)) {
+			v1 = (int) (e1.e_addr - dot.s_addr - 1);
+			if ((v1 < -128) || (v1 > 127))
+				aerr();
+			outab(v1);
+		} else {
+			outrb(&e1, R_PCR);
+		}
+		if (e1.e_mode != S_USER)
+			rerr();
+		break;
+
+	case S_LBRA:
+		cpg += 0x10;
+
+	case S_LBSR:
+		expr(&e1, 0);
+		if (cpg)
+			outab(cpg);
+		outab(op);
+		if (mchpcr(&e1)) {
+			v1 = (int) (e1.e_addr - dot.s_addr - 2);
+			outaw(v1);
+		} else {
+			outrw(&e1, R_PCR);
+		}
+		if (e1.e_mode != S_USER)
+			aerr();
+		break;
+
+	case S_PULS:
+		v1 = 0;
+		do {
+			if ((t1 = admode(stks)) == 0 || v1 & t1)
+				aerr();
+			v1 |= t1;
+		} while (more() && comma(1));
+		outab(op);
+		outab(v1);
+		break;
+
+	case S_PULU:
+		v1 = 0;
+		do {
+			if ((t1 = admode(stku)) == 0 || v1 & t1)
+				aerr();
+			v1 |= t1;
+		} while (more() && comma(1));
+		outab(op);
+		outab(v1);
+		break;
+
+	case S_EXG:
+		v1 = admode(regs);
+		comma(1);
+		v2 = admode(regs);
+		if ((v1 & 0x08) != (v2 & 0x08))
+			aerr();
+		outab(op);
+		outab((v1<<4)|v2);
+		break;
+
+	case S_ACC:
+		t1 = addr(&e1);
+		if (t1 == S_IMMED)
+			e1.e_mode = S_IMB;
+		genout(cpg, op, rf, &e1);
+		break;
+
+	case S_STR2:
+		cpg += 0x01;
+
+	case S_STR1:
+		cpg += 0x10;
+
+	case S_SOP:
+	case S_STR:
+		t1 = addr(&e1);
+		if (t1 == S_IMMED)
+			e1.e_mode = S_IMER;
+		genout(cpg, op, rf, &e1);
+		break;
+
+	case S_LR2:
+		cpg += 0x01;
+
+	case S_LR1:
+		cpg += 0x10;
+
+	case S_LR:
+		t1 = addr(&e1);
+		if (t1 == S_IMMED)
+			e1.e_mode = S_IMW;
+		genout(cpg, op, rf, &e1);
+		break;
+
+	case S_LEA:
+		t1 = addr(&e1);
+		if (aindx) {
+			genout(cpg, op, rf, &e1);
+			break;
+		}
+		aerr();
+		break;
+
+	case S_IMM2:
+		cpg += 0x01;
+
+	case S_IMM1:
+		cpg += 0x10;
+
+	case S_CC:
+		t1 = addr(&e1);
+		if (t1 == S_IMMED) {
+			e1.e_mode = S_IMB;
+			genout(cpg, op, rf, &e1);
+			break;
+		}
+		aerr();
+		break;
+
+#if	!M6809STRICT
+	case S_6800:
+		m68out(op);
+		opcycles = m00cyc[op];
+		break;
+#endif
+
+	default:
+		opcycles = OPCY_ERR;
+		err('o');
+		break;
+	}
+
+	if (opcycles == OPCY_NONE) {
+		v2 = 1;
+		opcycles = m09pg1[cb[0] & 0xFF];
+		if ((opcycles & OPCY_NONE) && (opcycles & OPCY_MASK)) {
+			v2 += 1;
+			opcycles = Page[opcycles & OPCY_MASK][cb[1] & 0xFF];
+		}
+		if (opcycles & OPCY_INDX) {
+			if (cb[v2] & 0x80) {
+				opcycles = (opcycles & VALU_MASK) + m09idx[cb[v2] & 0x1F];
+			} else {
+				opcycles = (opcycles & VALU_MASK) + 1;
+			}
+		} else
+		if (opcycles & OPCY_PSPL) {
+			for (t1=0x01,v1=0; t1 < 0x0100; t1 <<= 1) {
+				if (cb[1] & t1) {
+			    		v1 += 1;
+				}
+			}
+			opcycles = (opcycles & VALU_MASK) + v1;
+		}
+	}
+}
+
+/*
+ * General Output Routine
+ */
+VOID
+genout(cpg, op, rf, esp)
+int cpg, op, rf;
+struct expr *esp;
+{
+	int espv;
+	struct area *espa;
+	int disp, flag;
+
+	espv = (int) esp->e_addr;
+	espa = esp->e_base.e_ap;
+	switch (esp->e_mode) {
+
+	case S_IMB:
+		if (cpg)
+			outab(cpg);
+		outab(op);
+		outrb(esp, R_NORM);
+		break;
+
+	case S_IMW:
+		if (cpg)
+			outab(cpg);
+		outab(op);
+		outrw(esp, R_NORM);
+		break;
+
+	case S_DIR:
+		if (cpg)
+			outab(cpg);
+		if (rf == S_SOP) {
+			outab(op&0x0F);
+		} else {
+			outab(op|0x10);
+		}
+		outrb(esp, R_PAGN);
+		break;
+
+	case S_EXT:
+		if (cpg)
+			outab(cpg);
+		if (aindx) {
+			outab(op|0x20);
+			outab(aindx|0x0F);
+			outrw(esp, R_NORM);
+			break;
+		}
+		outab(op|0x30);
+		outrw(esp, R_NORM);
+		break;
+
+	case S_IND:
+		if (cpg)
+			outab(cpg);
+		outab(op|0x20);
+		outab(aindx);
+		break;
+
+	case S_PC:
+		if (espa) {
+			aerr();
+			break;
+		}
+		if (cpg)
+			outab(cpg);
+		outab(op|0x20);
+		if (pass == 0) {
+			dot.s_addr += 3;
+		} else
+		if (pass == 1) {
+			if (esp->e_addr >= dot.s_addr)
+				esp->e_addr -= fuzz;
+			dot.s_addr += 2;
+			disp = (int) esp->e_addr;
+			flag = 0;
+			if (disp < -128 || disp > 127)
+				++flag;
+			if (setbit(flag))
+				++dot.s_addr;
+		} else {
+			if (getbit()) {
+				outab(aindx|0x01);
+				outaw(espv);
+			} else {
+				outab(aindx);
+				outab(espv);
+			}
+		}
+		break;
+
+	case S_PCR:
+		if (cpg)
+			outab(cpg);
+		outab(op|0x20);
+		if (pass == 0) {
+			dot.s_addr += 3;
+		} else
+		if (espa && espa != dot.s_area) {
+			outab(aindx|0x01);
+			outrw(esp, R_PCR);
+		} else
+		if (pass == 1) {
+			if (esp->e_addr >= dot.s_addr)
+				esp->e_addr -= fuzz;
+			dot.s_addr += 2;
+			disp = (int) (esp->e_addr - dot.s_addr);
+			flag = 0;
+			if (disp < -128 || disp > 127)
+				++flag;
+			if (setbit(flag))
+				++dot.s_addr;
+		} else {
+			if (getbit()) {
+				outab(aindx|0x01);
+				disp = (int) (espv - dot.s_addr - 2);
+				outaw(disp);
+			} else {
+				outab(aindx);
+				disp = (int) (espv - dot.s_addr - 1);
+				outab(disp);
+			}
+		}
+		break;
+
+	case S_OFST:
+		if (cpg)
+			outab(cpg);
+		outab(op|0x20);
+		if (pass == 0) {
+			dot.s_addr += 3;
+		} else
+		if (espa) {
+			outab(aindx|0x09);
+			outrw(esp, R_NORM);
+		} else
+		if (pass == 1) {
+			if (esp->e_addr >= dot.s_addr)
+				esp->e_addr -= fuzz;
+			dot.s_addr += 1;
+			flag = 0;
+			if (espv < -128 || espv > 127)
+				++flag;
+			if (setbit(flag)) {
+				dot.s_addr += 2;
+			} else {
+				flag = aindx & 0x10;
+				if (espv < -16 || espv > 15)
+					++flag;
+				if (setbit(flag))
+					++dot.s_addr;
+			}
+		} else {
+			if (getbit()) {
+				outab(aindx|0x09);
+				outaw(espv);
+			} else {
+				if (getbit()) {
+					outab(aindx|0x08);
+					outab(espv);
+				} else {
+					outab((aindx & 0x60) | (espv & 0x1F));
+				}
+			}
+		}
+		break;
+
+	case S_IMER:
+	default:
+		aerr();
+	}
+}
+
+/*
+ * mc6800 compatibility output routine
+ */
+#if	!M6809STRICT
+VOID
+m68out(i)
+int i;
+{
+	char *ptr;
+	int j;
+
+	ptr = (char *) &mc6800[i];
+	for (j=0; j<4 ; j++) {
+		if ((i = *ptr++) != 0) {
+			outab(i);
+		} else {
+			break;
+		}
+	}
+}
+#endif
+
+/*
+ * Branch/Jump PCR Mode Check
+ */
+int
+mchpcr(esp)
+struct expr *esp;
+{
+	if (esp->e_base.e_ap == dot.s_area) {
+		return(1);
+	}
+	if (esp->e_flag==0 && esp->e_base.e_ap==NULL) {
+		/*
+		 * Absolute Destination
+		 *
+		 * Use the global symbol '.__.ABS.'
+		 * of value zero and force the assembler
+		 * to use this absolute constant as the
+		 * base value for the relocation.
+		 */
+		esp->e_flag = 1;
+		esp->e_base.e_sp = &sym[1];
+	}
+	return(0);
+}
+
+/*
+ * Machine specific initialization.
+ * Set up the bit table.
+ */
+VOID
+minit()
+{
+	/*
+	 * Byte Order
+	 */
+	hilo = 1;
+
+	bp = bb;
+	bm = 1;
+}
+
+/*
+ * Store `b' in the next slot of the bit table.
+ * If no room, force the longer form of the offset.
+ */
+int
+setbit(b)
+int b;
+{
+	if (bp >= &bb[NB])
+		return(1);
+	if (b)
+		*bp |= bm;
+	bm <<= 1;
+	if (bm == 0) {
+		bm = 1;
+		++bp;
+	}
+	return(b);
+}
+
+/*
+ * Get the next bit from the bit table.
+ * If none left, return a `1'.
+ * This will force the longer form of the offset.
+ */
+int
+getbit()
+{
+	register int f;
+
+	if (bp >= &bb[NB])
+		return (1);
+	f = *bp & bm;
+	bm <<= 1;
+	if (bm == 0) {
+		bm = 1;
+		++bp;
+	}
+	return (f);
+}
+
diff --git a/asxv5pxx/as6309/m09pst.c b/asxv5pxx/as6309/m09pst.c
new file mode 100644
index 0000000..5625fb5
--- /dev/null
+++ b/asxv5pxx/as6309/m09pst.c
@@ -0,0 +1,597 @@
+/* M09PST.C */
+
+/*
+ *  Copyright (C) 1989-2014  Alan R. Baldwin
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ * Alan R. Baldwin
+ * 721 Berkeley St.
+ * Kent, Ohio  44240
+ */
+
+#include "asxxxx.h"
+#include "m6809.h"
+
+/*
+ * Coding Banks
+ */
+struct	bank	bank[2] = {
+    /*	The '_CODE' area/bank has a NULL default file suffix.	*/
+    {	NULL,		"_CSEG",	NULL,		0,	0,	0,	0,	0	},
+    {	&bank[0],	"_DSEG",	"_DS",		1,	0,	0,	0,	B_FSFX	}
+};
+
+/*
+ * Coding Areas
+ */
+struct	area	area[2] = {
+    {	NULL,		&bank[0],	"_CODE",	0,	0,	0,	A_1BYTE|A_BNK|A_CSEG	},
+    {	&area[0],	&bank[1],	"_DATA",	1,	0,	0,	A_1BYTE|A_BNK|A_DSEG	}
+};
+
+/*
+ * Basic Relocation Mode Definition
+ *
+ *	#define		R_NORM	0000		No Bit Positioning
+ */
+char	mode0[32] = {	/* R_NORM */
+	'\200',	'\201',	'\202',	'\203',	'\204',	'\205',	'\206',	'\207',
+	'\210',	'\211',	'\212',	'\213',	'\214',	'\215',	'\216',	'\217',
+	'\220',	'\221',	'\222',	'\223',	'\224',	'\225',	'\226',	'\227',
+	'\230',	'\231',	'\232',	'\233',	'\234',	'\235',	'\236',	'\237'
+};
+
+/*
+ * Additional Relocation Mode Definitions
+ */
+
+/* None Required */
+
+/*
+ *     *m_def is a pointer to the bit relocation definition.
+ *	m_flag indicates that bit position swapping is required.
+ *	m_dbits contains the active bit positions for the output.
+ *	m_sbits contains the active bit positions for the input.
+ *
+ *	struct	mode
+ *	{
+ *		char *	m_def;		Bit Relocation Definition
+ *		a_uint	m_flag;		Bit Swapping Flag
+ *		a_uint	m_dbits;	Destination Bit Mask
+ *		a_uint	m_sbits;	Source Bit Mask
+ *	};
+ */
+struct	mode	mode[1] = {
+    {	&mode0[0],	0,	0x0000FFFF,	0x0000FFFF	}
+};
+
+/*
+ * Array of Pointers to mode Structures
+ */
+struct	mode	*modep[16] = {
+	&mode[0],	NULL,		NULL,		NULL,
+	NULL,		NULL,		NULL,		NULL,
+	NULL,		NULL,		NULL,		NULL,
+	NULL,		NULL,		NULL,		NULL
+};
+
+/*
+ * Mnemonic Structure
+ */
+struct	mne	mne[] = {
+
+	/* machine */
+
+    {	NULL,	"CSEG",		S_ATYP,		0,	A_CSEG|A_1BYTE	},
+    {	NULL,	"DSEG",		S_ATYP,		0,	A_DSEG|A_1BYTE	},
+
+    {	NULL,	".setdp",	S_SDP,		0,	0	},
+
+	/* system */
+
+    {	NULL,	"BANK",		S_ATYP,		0,	A_BNK	},
+    {	NULL,	"CON",		S_ATYP,		0,	A_CON	},
+    {	NULL,	"OVR",		S_ATYP,		0,	A_OVR	},
+    {	NULL,	"REL",		S_ATYP,		0,	A_REL	},
+    {	NULL,	"ABS",		S_ATYP,		0,	A_ABS	},
+    {	NULL,	"NOPAG",	S_ATYP,		0,	A_NOPAG	},
+    {	NULL,	"PAG",		S_ATYP,		0,	A_PAG	},
+
+    {	NULL,	"BASE",		S_BTYP,		0,	B_BASE	},
+    {	NULL,	"SIZE",		S_BTYP,		0,	B_SIZE	},
+    {	NULL,	"FSFX",		S_BTYP,		0,	B_FSFX	},
+    {	NULL,	"MAP",		S_BTYP,		0,	B_MAP	},
+
+    {	NULL,	".page",	S_PAGE,		0,	0	},
+    {	NULL,	".title",	S_HEADER,	0,	O_TITLE	},
+    {	NULL,	".sbttl",	S_HEADER,	0,	O_SBTTL	},
+    {	NULL,	".module",	S_MODUL,	0,	0	},
+    {	NULL,	".include",	S_INCL,		0,	0	},
+    {	NULL,	".area",	S_AREA,		0,	0	},
+    {	NULL,	".bank",	S_BANK,		0,	0	},
+    {	NULL,	".org",		S_ORG,		0,	0	},
+    {	NULL,	".radix",	S_RADIX,	0,	0	},
+    {	NULL,	".globl",	S_GLOBL,	0,	0	},
+    {	NULL,	".local",	S_LOCAL,	0,	0	},
+    {	NULL,	".if",		S_CONDITIONAL,	0,	O_IF	},
+    {	NULL,	".iff",		S_CONDITIONAL,	0,	O_IFF	},
+    {	NULL,	".ift",		S_CONDITIONAL,	0,	O_IFT	},
+    {	NULL,	".iftf",	S_CONDITIONAL,	0,	O_IFTF	},
+    {	NULL,	".ifdef",	S_CONDITIONAL,	0,	O_IFDEF	},
+    {	NULL,	".ifndef",	S_CONDITIONAL,	0,	O_IFNDEF},
+    {	NULL,	".ifgt",	S_CONDITIONAL,	0,	O_IFGT	},
+    {	NULL,	".iflt",	S_CONDITIONAL,	0,	O_IFLT	},
+    {	NULL,	".ifge",	S_CONDITIONAL,	0,	O_IFGE	},
+    {	NULL,	".ifle",	S_CONDITIONAL,	0,	O_IFLE	},
+    {	NULL,	".ifeq",	S_CONDITIONAL,	0,	O_IFEQ	},
+    {	NULL,	".ifne",	S_CONDITIONAL,	0,	O_IFNE	},
+    {	NULL,	".ifb",		S_CONDITIONAL,	0,	O_IFB	},
+    {	NULL,	".ifnb",	S_CONDITIONAL,	0,	O_IFNB	},
+    {	NULL,	".ifidn",	S_CONDITIONAL,	0,	O_IFIDN	},
+    {	NULL,	".ifdif",	S_CONDITIONAL,	0,	O_IFDIF	},
+    {	NULL,	".iif",		S_CONDITIONAL,	0,	O_IIF	},
+    {	NULL,	".iiff",	S_CONDITIONAL,	0,	O_IIFF	},
+    {	NULL,	".iift",	S_CONDITIONAL,	0,	O_IIFT	},
+    {	NULL,	".iiftf",	S_CONDITIONAL,	0,	O_IIFTF	},
+    {	NULL,	".iifdef",	S_CONDITIONAL,	0,	O_IIFDEF},
+    {	NULL,	".iifndef",	S_CONDITIONAL,	0,	O_IIFNDEF},
+    {	NULL,	".iifgt",	S_CONDITIONAL,	0,	O_IIFGT	},
+    {	NULL,	".iiflt",	S_CONDITIONAL,	0,	O_IIFLT	},
+    {	NULL,	".iifge",	S_CONDITIONAL,	0,	O_IIFGE	},
+    {	NULL,	".iifle",	S_CONDITIONAL,	0,	O_IIFLE	},
+    {	NULL,	".iifeq",	S_CONDITIONAL,	0,	O_IIFEQ	},
+    {	NULL,	".iifne",	S_CONDITIONAL,	0,	O_IIFNE	},
+    {	NULL,	".iifb",	S_CONDITIONAL,	0,	O_IIFB	},
+    {	NULL,	".iifnb",	S_CONDITIONAL,	0,	O_IIFNB	},
+    {	NULL,	".iifidn",	S_CONDITIONAL,	0,	O_IIFIDN},
+    {	NULL,	".iifdif",	S_CONDITIONAL,	0,	O_IIFDIF},
+    {	NULL,	".else",	S_CONDITIONAL,	0,	O_ELSE	},
+    {	NULL,	".endif",	S_CONDITIONAL,	0,	O_ENDIF	},
+    {	NULL,	".list",	S_LISTING,	0,	O_LIST	},
+    {	NULL,	".nlist",	S_LISTING,	0,	O_NLIST	},
+    {	NULL,	".equ",		S_EQU,		0,	O_EQU	},
+    {	NULL,	".gblequ",	S_EQU,		0,	O_GBLEQU},
+    {	NULL,	".lclequ",	S_EQU,		0,	O_LCLEQU},
+    {	NULL,	".byte",	S_DATA,		0,	O_1BYTE	},
+    {	NULL,	".db",		S_DATA,		0,	O_1BYTE	},
+    {	NULL,	".fcb",		S_DATA,		0,	O_1BYTE	},
+    {	NULL,	".word",	S_DATA,		0,	O_2BYTE	},
+    {	NULL,	".dw",		S_DATA,		0,	O_2BYTE	},
+    {	NULL,	".fdb",		S_DATA,		0,	O_2BYTE	},
+/*    {	NULL,	".3byte",	S_DATA,		0,	O_3BYTE	},	*/
+/*    {	NULL,	".triple",	S_DATA,		0,	O_3BYTE	},	*/
+/*    {	NULL,	".4byte",	S_DATA,		0,	O_4BYTE	},	*/
+/*    {	NULL,	".quad",	S_DATA,		0,	O_4BYTE	},	*/
+    {	NULL,	".blkb",	S_BLK,		0,	O_1BYTE	},
+    {	NULL,	".ds",		S_BLK,		0,	O_1BYTE	},
+    {	NULL,	".rmb",		S_BLK,		0,	O_1BYTE	},
+    {	NULL,	".rs",		S_BLK,		0,	O_1BYTE	},
+    {	NULL,	".blkw",	S_BLK,		0,	O_2BYTE	},
+/*    {	NULL,	".blk3",	S_BLK,		0,	O_3BYTE	},	*/
+/*    {	NULL,	".blk4",	S_BLK,		0,	O_4BYTE	},	*/
+    {	NULL,	".ascii",	S_ASCIX,	0,	O_ASCII	},
+    {	NULL,	".ascis",	S_ASCIX,	0,	O_ASCIS	},
+    {	NULL,	".asciz",	S_ASCIX,	0,	O_ASCIZ	},
+    {	NULL,	".str",		S_ASCIX,	0,	O_ASCII	},
+    {	NULL,	".strs",	S_ASCIX,	0,	O_ASCIS	},
+    {	NULL,	".strz",	S_ASCIX,	0,	O_ASCIZ	},
+    {	NULL,	".fcc",		S_ASCIX,	0,	O_ASCII	},
+    {	NULL,	".define",	S_DEFINE,	0,	O_DEF	},
+    {	NULL,	".undefine",	S_DEFINE,	0,	O_UNDEF	},
+    {	NULL,	".even",	S_BOUNDARY,	0,	O_EVEN	},
+    {	NULL,	".odd",		S_BOUNDARY,	0,	O_ODD	},
+    {	NULL,	".bndry",	S_BOUNDARY,	0,	O_BNDRY	},
+    {	NULL,	".msg"	,	S_MSG,		0,	0	},
+    {	NULL,	".assume",	S_ERROR,	0,	O_ASSUME},
+    {	NULL,	".error",	S_ERROR,	0,	O_ERROR	},
+/*    {	NULL,	".msb",		S_MSB,		0,	0	},	*/
+/*    {	NULL,	".lohi",	S_MSB,		0,	O_LOHI	},	*/
+/*    {	NULL,	".hilo",	S_MSB,		0,	O_HILO	},	*/
+/*    {	NULL,	".8bit",	S_BITS,		0,	O_1BYTE	},	*/
+/*    {	NULL,	".16bit",	S_BITS,		0,	O_2BYTE	},	*/
+/*    {	NULL,	".24bit",	S_BITS,		0,	O_3BYTE	},	*/
+/*    {	NULL,	".32bit",	S_BITS,		0,	O_4BYTE	},	*/
+    {	NULL,	".end",		S_END,		0,	0	},
+
+	/* Macro Processor */
+
+    {	NULL,	".macro",	S_MACRO,	0,	O_MACRO	},
+    {	NULL,	".endm",	S_MACRO,	0,	O_ENDM	},
+    {	NULL,	".mexit",	S_MACRO,	0,	O_MEXIT	},
+
+    {	NULL,	".narg",	S_MACRO,	0,	O_NARG	},
+    {	NULL,	".nchr",	S_MACRO,	0,	O_NCHR	},
+    {	NULL,	".ntyp",	S_MACRO,	0,	O_NTYP	},
+
+    {	NULL,	".irp",		S_MACRO,	0,	O_IRP	},
+    {	NULL,	".irpc",	S_MACRO,	0,	O_IRPC	},
+    {	NULL,	".rept",	S_MACRO,	0,	O_REPT	},
+
+    {	NULL,	".nval",	S_MACRO,	0,	O_NVAL	},
+
+    {	NULL,	".mdelete",	S_MACRO,	0,	O_MDEL	},
+
+	/* 6800 Compatibility */
+
+#if	!M6809STRICT
+    {	NULL,	"ldaa",		S_ACC,		0,	0x86	},
+    {	NULL,	"ldab",		S_ACC,		0,	0xC6	},
+    {	NULL,	"oraa",		S_ACC,		0,	0x8A	},
+    {	NULL,	"orab",		S_ACC,		0,	0xCA	},
+    {	NULL,	"staa",		S_STR,		0,	0x87	},
+    {	NULL,	"stab",		S_STR,		0,	0xC7	},
+
+	/* if this is changed, change struct opdata mc6800[] */
+
+    {	NULL,	"aba",		S_6800,		0,	0	},
+    {	NULL,	"cba",		S_6800,		0,	1	},
+    {	NULL,	"clc",		S_6800,		0,	2	},
+    {	NULL,	"cli",		S_6800,		0,	3	},
+    {	NULL,	"clv",		S_6800,		0,	4	},
+    {	NULL,	"des",		S_6800,		0,	5	},
+    {	NULL,	"dex",		S_6800,		0,	6	},
+    {	NULL,	"ins",		S_6800,		0,	7	},
+    {	NULL,	"inx",		S_6800,		0,	8	},
+    {	NULL,	"psha",		S_6800,		0,	9	},
+    {	NULL,	"pshb",		S_6800,		0,	10	},
+    {	NULL,	"pula",		S_6800,		0,	11	},
+    {	NULL,	"pulb",		S_6800,		0,	12	},
+    {	NULL,	"sba",		S_6800,		0,	13	},
+    {	NULL,	"sec",		S_6800,		0,	14	},
+    {	NULL,	"sei",		S_6800,		0,	15	},
+    {	NULL,	"sev",		S_6800,		0,	16	},
+    {	NULL,	"tab",		S_6800,		0,	17	},
+    {	NULL,	"tap",		S_6800,		0,	18	},
+    {	NULL,	"tba",		S_6800,		0,	19	},
+    {	NULL,	"tpa",		S_6800,		0,	20	},
+    {	NULL,	"tsx",		S_6800,		0,	21	},
+    {	NULL,	"txs",		S_6800,		0,	22	},
+    {	NULL,	"wai",		S_6800,		0,	23	},
+#endif
+
+	/* 6809 */
+
+    {	NULL,	"sty",		S_STR1,		0,	0x8F	},
+    {	NULL,	"sts",		S_STR1,		0,	0xCF	},
+
+    {	NULL,	"sta",		S_STR,		0,	0x87	},
+    {	NULL,	"stb",		S_STR,		0,	0xC7	},
+    {	NULL,	"std",		S_STR,		0,	0xCD	},
+    {	NULL,	"stx",		S_STR,		0,	0x8F	},
+    {	NULL,	"stu",		S_STR,		0,	0xCF	},
+    {	NULL,	"jsr",		S_STR,		0,	0x8D	},
+
+    {	NULL,	"cmpu",		S_LR2,		0,	0x83	},
+    {	NULL,	"cmps",		S_LR2,		0,	0x8C	},
+
+    {	NULL,	"cmpd",		S_LR1,		0,	0x83	},
+    {	NULL,	"cmpy",		S_LR1,		0,	0x8C	},
+    {	NULL,	"ldy",		S_LR1,		0,	0x8E	},
+    {	NULL,	"lds",		S_LR1,		0,	0xCE	},
+
+    {	NULL,	"subd",		S_LR,		0,	0x83	},
+    {	NULL,	"addd",		S_LR,		0,	0xC3	},
+    {	NULL,	"cmpx",		S_LR,		0,	0x8C	},
+#if	!M6809STRICT
+    {	NULL,	"cpx",		S_LR,		0,	0x8C	},
+#endif
+    {	NULL,	"ldd",		S_LR,		0,	0xCC	},
+    {	NULL,	"ldx",		S_LR,		0,	0x8E	},
+    {	NULL,	"ldu",		S_LR,		0,	0xCE	},
+    {	NULL,	"ldq",		S_LRQ,		0,	0xCD	},
+
+    {	NULL,	"leax",		S_LEA,		0,	0x30	},
+    {	NULL,	"leay",		S_LEA,		0,	0x31	},
+    {	NULL,	"leas",		S_LEA,		0,	0x32	},
+    {	NULL,	"leau",		S_LEA,		0,	0x33	},
+
+    {	NULL,	"pshs",		S_PULS,		0,	0x34	},
+    {	NULL,	"puls",		S_PULS,		0,	0x35	},
+    {	NULL,	"pshu",		S_PULU,		0,	0x36	},
+    {	NULL,	"pulu",		S_PULU,		0,	0x37	},
+
+    {	NULL,	"exg",		S_EXG,		0,	0x1E	},
+    {	NULL,	"tfr",		S_EXG,		0,	0x1F	},
+
+    {	NULL,	"addr",		S_IR,		0,	0x30	},
+    {	NULL,	"adcr",		S_IR,		0,	0x31	},
+    {	NULL,	"subr",		S_IR,		0,	0x32	},
+    {	NULL,	"sbcr",		S_IR,		0,	0x33	},
+    {	NULL,	"andr",		S_IR,		0,	0x34	},
+    {	NULL,	"orr",		S_IR,		0,	0x35	},
+    {	NULL,	"eorr",		S_IR,		0,	0x36	},
+    {	NULL,	"cmpr",		S_IR,		0,	0x37	},
+
+    {	NULL,	"cwai",		S_CC,		0,	0x3C	},
+    {	NULL,	"orcc",		S_CC,		0,	0x1A	},
+    {	NULL,	"andcc",	S_CC,		0,	0x1C	},
+
+    {	NULL,	"swi3",		S_INH2,		0,	0x3F	},
+    {	NULL,	"swi2",		S_INH1,		0,	0x3F	},
+#if	!M6809STRICT
+    {	NULL,	"swi1",		S_INH,		0,	0x3F	},
+#endif
+
+    {	NULL,	"abx",		S_INH,		0,	0x3A	},
+    {	NULL,	"asla",		S_INH,		0,	0x48	},
+    {	NULL,	"aslb",		S_INH,		0,	0x58	},
+    {	NULL,	"asra",		S_INH,		0,	0x47	},
+    {	NULL,	"asrb",		S_INH,		0,	0x57	},
+    {	NULL,	"clra",		S_INH,		0,	0x4F	},
+    {	NULL,	"clrb",		S_INH,		0,	0x5F	},
+    {	NULL,	"coma",		S_INH,		0,	0x43	},
+    {	NULL,	"comb",		S_INH,		0,	0x53	},
+    {	NULL,	"daa",		S_INH,		0,	0x19	},
+    {	NULL,	"deca",		S_INH,		0,	0x4A	},
+    {	NULL,	"decb",		S_INH,		0,	0x5A	},
+    {	NULL,	"inca",		S_INH,		0,	0x4C	},
+    {	NULL,	"incb",		S_INH,		0,	0x5C	},
+    {	NULL,	"lsla",		S_INH,		0,	0x48	},
+    {	NULL,	"lslb",		S_INH,		0,	0x58	},
+    {	NULL,	"lsra",		S_INH,		0,	0x44	},
+    {	NULL,	"lsrb",		S_INH,		0,	0x54	},
+    {	NULL,	"mul",		S_INH,		0,	0x3D	},
+    {	NULL,	"nega",		S_INH,		0,	0x40	},
+    {	NULL,	"negb",		S_INH,		0,	0x50	},
+    {	NULL,	"nop",		S_INH,		0,	0x12	},
+    {	NULL,	"rola",		S_INH,		0,	0x49	},
+    {	NULL,	"rolb",		S_INH,		0,	0x59	},
+    {	NULL,	"rora",		S_INH,		0,	0x46	},
+    {	NULL,	"rorb",		S_INH,		0,	0x56	},
+    {	NULL,	"rti",		S_INH,		0,	0x3B	},
+    {	NULL,	"rts",		S_INH,		0,	0x39	},
+    {	NULL,	"sex",		S_INH,		0,	0x1D	},
+    {	NULL,	"swi",		S_INH,		0,	0x3F	},
+    {	NULL,	"sync",		S_INH,		0,	0x13	},
+    {	NULL,	"tsta",		S_INH,		0,	0x4D	},
+    {	NULL,	"tstb",		S_INH,		0,	0x5D	},
+
+    {	NULL,	"lbrn",		S_LBRA,		0,	0x21	},
+    {	NULL,	"lbhi",		S_LBRA,		0,	0x22	},
+    {	NULL,	"lbls",		S_LBRA,		0,	0x23	},
+#if	!M6809STRICT
+    {	NULL,	"lblos",	S_LBRA,		0,	0x23	},
+#endif
+    {	NULL,	"lbcc",		S_LBRA,		0,	0x24	},
+    {	NULL,	"lbhs",		S_LBRA,		0,	0x24	},
+#if	!M6809STRICT
+    {	NULL,	"lbhis",	S_LBRA,		0,	0x24	},
+#endif
+    {	NULL,	"lbcs",		S_LBRA,		0,	0x25	},
+    {	NULL,	"lblo",		S_LBRA,		0,	0x25	},
+    {	NULL,	"lbne",		S_LBRA,		0,	0x26	},
+    {	NULL,	"lbeq",		S_LBRA,		0,	0x27	},
+    {	NULL,	"lbvc",		S_LBRA,		0,	0x28	},
+    {	NULL,	"lbvs",		S_LBRA,		0,	0x29	},
+    {	NULL,	"lbpl",		S_LBRA,		0,	0x2A	},
+    {	NULL,	"lbmi",		S_LBRA,		0,	0x2B	},
+    {	NULL,	"lbge",		S_LBRA,		0,	0x2C	},
+    {	NULL,	"lblt",		S_LBRA,		0,	0x2D	},
+    {	NULL,	"lbgt",		S_LBRA,		0,	0x2E	},
+    {	NULL,	"lble",		S_LBRA,		0,	0x2F	},
+
+    {	NULL,	"lbra",		S_LBSR,		0,	0x16	},
+    {	NULL,	"lbsr",		S_LBSR,		0,	0x17	},
+
+    {	NULL,	"neg",		S_SOP,		0,	0x40	},
+    {	NULL,	"oim",		S_SOP,		0,	0x41	},
+    {	NULL,	"aim",		S_SOP,		0,	0x42	},
+    {	NULL,	"com",		S_SOP,		0,	0x43	},
+    {	NULL,	"lsr",		S_SOP,		0,	0x44	},
+    {	NULL,	"eim",		S_SOP,		0,	0x45	},
+    {	NULL,	"ror",		S_SOP,		0,	0x46	},
+    {	NULL,	"asr",		S_SOP,		0,	0x47	},
+    {	NULL,	"asl",		S_SOP,		0,	0x48	},
+    {	NULL,	"lsl",		S_SOP,		0,	0x48	},
+    {	NULL,	"rol",		S_SOP,		0,	0x49	},
+    {	NULL,	"dec",		S_SOP,		0,	0x4A	},
+    {	NULL,	"tim",		S_SOP,		0,	0x4B	},
+    {	NULL,	"inc",		S_SOP,		0,	0x4C	},
+    {	NULL,	"tst",		S_SOP,		0,	0x4D	},
+    {	NULL,	"clr",		S_SOP,		0,	0x4F	},
+    {	NULL,	"jmp",		S_SOP,		0,	0x4E	},
+
+    {	NULL,	"suba",		S_ACC,		0,	0x80	},
+    {	NULL,	"subb",		S_ACC,		0,	0xC0	},
+    {	NULL,	"cmpa",		S_ACC,		0,	0x81	},
+    {	NULL,	"cmpb",		S_ACC,		0,	0xC1	},
+    {	NULL,	"sbca",		S_ACC,		0,	0x82	},
+    {	NULL,	"sbcb",		S_ACC,		0,	0xC2	},
+    {	NULL,	"anda",		S_ACC,		0,	0x84	},
+    {	NULL,	"andb",		S_ACC,		0,	0xC4	},
+    {	NULL,	"bita",		S_ACC,		0,	0x85	},
+    {	NULL,	"bitb",		S_ACC,		0,	0xC5	},
+    {	NULL,	"lda",		S_ACC,		0,	0x86	},
+    {	NULL,	"ldb",		S_ACC,		0,	0xC6	},
+    {	NULL,	"eora",		S_ACC,		0,	0x88	},
+    {	NULL,	"eorb",		S_ACC,		0,	0xC8	},
+    {	NULL,	"adca",		S_ACC,		0,	0x89	},
+    {	NULL,	"adcb",		S_ACC,		0,	0xC9	},
+    {	NULL,	"ora",		S_ACC,		0,	0x8A	},
+    {	NULL,	"orb",		S_ACC,		0,	0xCA	},
+    {	NULL,	"adda",		S_ACC,		0,	0x8B	},
+    {	NULL,	"addb",		S_ACC,		0,	0xCB	},
+
+    {	NULL,	"bra",		S_BRA,		0,	0x20	},
+    {	NULL,	"brn",		S_BRA,		0,	0x21	},
+    {	NULL,	"bhi",		S_BRA,		0,	0x22	},
+    {	NULL,	"bls",		S_BRA,		0,	0x23	},
+#if	!M6809STRICT
+    {	NULL,	"blos",		S_BRA,		0,	0x23	},
+#endif
+    {	NULL,	"bcc",		S_BRA,		0,	0x24	},
+    {	NULL,	"bhs",		S_BRA,		0,	0x24	},
+#if	!M6809STRICT
+    {	NULL,	"bhis",		S_BRA,		0,	0x24	},
+#endif
+    {	NULL,	"bcs",		S_BRA,		0,	0x25	},
+    {	NULL,	"blo",		S_BRA,		0,	0x25	},
+    {	NULL,	"bne",		S_BRA,		0,	0x26	},
+    {	NULL,	"beq",		S_BRA,		0,	0x27	},
+    {	NULL,	"bvc",		S_BRA,		0,	0x28	},
+    {	NULL,	"bvs",		S_BRA,		0,	0x29	},
+    {	NULL,	"bpl",		S_BRA,		0,	0x2A	},
+    {	NULL,	"bmi",		S_BRA,		0,	0x2B	},
+    {	NULL,	"bge",		S_BRA,		0,	0x2C	},
+    {	NULL,	"blt",		S_BRA,		0,	0x2D	},
+    {	NULL,	"bgt",		S_BRA,		0,	0x2E	},
+    {	NULL,	"ble",		S_BRA,		0,	0x2F	},
+
+		/* New to the 6309 - prebyte 0x10 */
+
+    {	NULL,	"negd",		S_INH1,		0,	0x40	},
+    {	NULL,	"comd",		S_INH1,		0,	0x43	},
+    {	NULL,	"lsrd",		S_INH1,		0,	0x44	},
+    {	NULL,	"rord",		S_INH1,		0,	0x46	},
+    {	NULL,	"asrd",		S_INH1,		0,	0x47	},
+    {	NULL,	"asld",		S_INH1,		0,	0x48	},
+    {	NULL,	"rold",		S_INH1,		0,	0x49	},
+    {	NULL,	"decd",		S_INH1,		0,	0x4A	},
+    {	NULL,	"incd",		S_INH1,		0,	0x4C	},
+    {	NULL,	"tstd",		S_INH1,		0,	0x4D	},
+    {	NULL,	"clrd",		S_INH1,		0,	0x4F	},
+
+    {	NULL,	"comw",		S_INH1,		0,	0x53	},
+    {	NULL,	"lsrw",		S_INH1,		0,	0x54	},
+    {	NULL,	"rorw",		S_INH1,		0,	0x56	},
+    {	NULL,	"rolw",		S_INH1,		0,	0x59	},
+    {	NULL,	"decw",		S_INH1,		0,	0x5A	},
+    {	NULL,	"incw",		S_INH1,		0,	0x5C	},
+    {	NULL,	"tstw",		S_INH1,		0,	0x5D	},
+    {	NULL,	"clrw",		S_INH1,		0,	0x5F	},
+
+    {	NULL,	"subw",		S_LR1,		0,	0x80	},
+    {	NULL,	"cmpw",		S_LR1,		0,	0x81	},
+    {	NULL,	"sbcd",		S_LR1,		0,	0x82	},
+    {	NULL,	"andd",		S_LR1,		0,	0x84	},
+    {	NULL,	"bitd",		S_LR1,		0,	0x85	},
+    {	NULL,	"ldw",		S_LR1,		0,	0x86	},
+    {	NULL,	"stw",		S_STR1,		0,	0x87	},
+    {	NULL,	"eord",		S_LR1,		0,	0x88	},
+    {	NULL,	"adcd",		S_LR1,		0,	0x89	},
+    {	NULL,	"ord",		S_LR1,		0,	0x8A	},
+    {	NULL,	"addw",		S_LR1,		0,	0x8B	},
+
+		/* New to the 6309 - prebyte 0x11 */
+
+    {	NULL,	"bitmd",	S_IMM2,		0,	0x3C	},
+    {	NULL,	"ldmd",		S_IMM2,		0,	0x3D	},
+
+    {	NULL,	"come",		S_INH2,		0,	0x43	},
+    {	NULL,	"dece",		S_INH2,		0,	0x4A	},
+    {	NULL,	"ince",		S_INH2,		0,	0x4C	},
+    {	NULL,	"tste",		S_INH2,		0,	0x4D	},
+    {	NULL,	"clre",		S_INH2,		0,	0x4F	},
+
+    {	NULL,	"comf",		S_INH2,		0,	0x53	},
+    {	NULL,	"decf",		S_INH2,		0,	0x5A	},
+    {	NULL,	"incf",		S_INH2,		0,	0x5C	},
+    {	NULL,	"tstf",		S_INH2,		0,	0x5D	},
+    {	NULL,	"clrf",		S_INH2,		0,	0x5F	},
+
+    {	NULL,	"sube",		S_LR2,		0,	0x80	},
+    {	NULL,	"cmpe",		S_LR2,		0,	0x81	},
+    {	NULL,	"lde",		S_LR2,		0,	0x86	},
+    {	NULL,	"ste",		S_STR2,		0,	0x87	},
+    {	NULL,	"adde",		S_LR2,		0,	0x8B	},
+    {	NULL,	"divd",		S_LR2,		0,	0x8D	},
+    {	NULL,	"muld",		S_LR2,		0,	0x8F	},
+
+    {	NULL,	"subf",		S_LR2,		0,	0xC0	},
+    {	NULL,	"cmpf",		S_LR2,		0,	0xC1	},
+    {	NULL,	"ldf",		S_LR2,		0,	0xC6	},
+    {	NULL,	"stf",		S_STR2,		0,	0xC7	},
+    {	NULL,	"addf",		S_LR2,		0,	0xCB	},
+
+    {	NULL,	"bsr",		S_BRA,		S_EOL,	0x8D	}
+};
+
+#if	!M6809STRICT
+struct opdata mc6800[] = {
+
+    {{	(char) 0x34, (char) 0x04,	/*	pshs	b	;aba	*/
+	(char) 0xab, (char) 0xe0	/*	adda	,s+	*/	}},
+
+    {{	(char) 0x34, (char) 0x04,	/*	pshs	b	;cba	*/
+	(char) 0xa1, (char) 0xe0	/*	cmpa	,s+	*/	}},
+
+    {{	(char) 0x1c, (char) 0xfe,	/*	andcc	#0xFE	;clc	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1c, (char) 0xef,	/*	andcc	#0xEF	;cli	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1c, (char) 0xfd,	/*	andcc	#0xFD	;clv	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x32, (char) 0x7f,	/*	leas	-1,s	;des	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x30, (char) 0x1f,	/*	leax	-1,x	;dex	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x32, (char) 0x61,	/*	leas	1,s	;ins	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x30, (char) 0x01,	/*	leax	1,x	;inx	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x34, (char) 0x02,	/*	pshs	a	;psha	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x34, (char) 0x04,	/*	pshs	b	;pshb	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x35, (char) 0x02,	/*	puls	a	;pula	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x35, (char) 0x04,	/*	puls	b	;pulb	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x34, (char) 0x04,	/*	pshs	b	;sba	*/
+	(char) 0xa0, (char) 0xe0	/*	suba	,s+	*/	}},
+
+    {{	(char) 0x1a, (char) 0x01,	/*	orcc	#0x01	;sec	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1a, (char) 0x10,	/*	orcc	#0x10	;sei	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1a, (char) 0x02,	/*	orcc	#0x02	;sev	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1f, (char) 0x89,	/*	tfr	a,b	;tab	*/
+	(char) 0x4d, (char) 0x00	/*	tsta	*/	}},
+
+    {{	(char) 0x1f, (char) 0x8a,	/*	tfr	a,cc	;tap	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1f, (char) 0x98,	/*	tfr	b,a	;tba	*/
+	(char) 0x5d, (char) 0x00	/*	tstb	*/	}},
+
+    {{	(char) 0x1f, (char) 0xa8,	/*	tfr	cc,a	;tpa	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1f, (char) 0x41,	/*	tfr	s,x	;tsx	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x1f, (char) 0x14,	/*	tfr	x,s	;txs	*/
+	(char) 0x00, (char) 0x00	}},
+
+    {{	(char) 0x3c, (char) 0xff,	/*	cwai	#0xFF	;wai	*/
+	(char) 0x00, (char) 0x00	}}
+};
+#endif
diff --git a/asxv5pxx/as6309/m6809.h b/asxv5pxx/as6309/m6809.h
new file mode 100644
index 0000000..961f063
--- /dev/null
+++ b/asxv5pxx/as6309/m6809.h
@@ -0,0 +1,183 @@
+/* m6809.h */
+
+/*
+ *  Copyright (C) 1989-2014  Alan R. Baldwin
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ * Alan R. Baldwin
+ * 721 Berkeley St.
+ * Kent, Ohio  44240
+ */
+
+/*)BUILD
+	$(PROGRAM) =	AS6309
+	$(INCLUDE) = {
+		ASXXXX.H
+		M6809.H
+	}
+	$(FILES) = {
+		M09MCH.C
+		M09ADR.C
+		M09PST.C
+		ASMAIN.C
+		ASMCRO.C
+		ASDBG.C
+		ASLEX.C
+		ASSYM.C
+		ASSUBR.C
+		ASEXPR.C
+		ASDATA.C
+		ASLIST.C
+		ASOUT.C
+	}
+	$(STACK) = 3000
+*/
+
+/*
+ * Addressing types
+ */
+#define	S_EXT	30
+#define	S_IMMED	31
+#define	S_IMB	32
+#define	S_IMW	33
+#define	S_IMER	34
+#define	S_DIR	35
+#define	S_IND	36
+#define	S_OFST	37
+#define	S_PC	38
+#define	S_PCR	39
+
+/*
+ * 6809 Instruction types
+ */
+#define	S_BRA	40
+#define	S_LBRA	41
+#define	S_LBSR	42
+#define	S_SOP	43
+#define	S_ACC	44
+#define	S_STR1	45
+#define	S_STR	46
+#define	S_LR2	47
+#define	S_LR1	48
+#define	S_LR	49
+#define	S_LEA	50
+#define	S_PULS	51
+#define	S_PULU	52
+#define	S_EXG	53
+#define	S_CC	54
+#define	S_INH2	55
+#define	S_INH1	56
+#define	S_INH	57
+#define	S_LRQ	58
+#define	S_IR	59
+#define	S_IMM1	60
+#define	S_IMM2	61
+#define	S_STR2	62
+
+/*
+ * Other Information
+ */
+#define	S_FLAG	69
+
+/*
+ * 6800 Instruction types
+ */
+#if	!M6809STRICT
+#define	S_6800	70
+#endif
+
+/*
+ * Set Direct Pointer
+ */
+#define	S_SDP	80
+
+
+extern	int	aindx;
+
+struct	sdp
+{
+	a_uint	s_addr;
+	struct	area *	s_area;
+};
+
+struct adsym
+{
+	char	a_str[4];	/* addressing string */
+	int	a_val;		/* addressing mode value */
+};
+
+extern struct adsym abd[];
+extern struct adsym xyus[];
+extern struct adsym auto1[];
+extern struct adsym auto2[];
+extern struct adsym pc[];
+extern struct adsym pcr[];
+extern struct adsym regs[];
+extern struct adsym stks[];
+extern struct adsym stku[];
+
+struct opdata
+{
+	char	opcode[4];	/* byte data */
+};
+
+#if	!M6809STRICT
+extern struct opdata mc6800[];
+#endif
+
+
+	/* machine dependent functions */
+
+#ifdef	OTHERSYSTEM
+	
+	/* m09adr.c */
+extern	int		addr(struct expr *esp);
+extern	int		addr1(struct expr *esp);
+extern	int		admode(struct adsym *sp);
+extern	int		any(int c, char *str);
+extern	int		srch(char *str);
+
+	/* m09mch.c */
+extern	VOID		machine(struct mne *mp);
+extern	VOID		genout(int cpg, int op, int rf, struct expr *esp);
+extern	VOID		m68out(int i);
+extern	int		mchpcr(struct expr *esp);
+extern	VOID		minit(void);
+extern	int		setbit(int b);
+extern	int		getbit(void);
+extern	struct	sdp	sdp;
+
+#else
+
+	/* m09adr.c */
+extern	int		addr();
+extern	int		addr1();
+extern	int		admode();
+extern	int		any();
+extern	int		srch();
+
+	/* m09mch.c */
+extern	VOID		machine();
+extern	VOID		genout();
+extern	VOID		m68out();
+extern	int		mchpcr();
+extern	VOID		minit();
+extern	int		setbit();
+extern	int		getbit();
+extern	struct	sdp	sdp;
+
+#endif
+
diff --git a/asxv5pxx/as6309/t6309.asm b/asxv5pxx/as6309/t6309.asm
new file mode 100644
index 0000000..d1e598d
--- /dev/null
+++ b/asxv5pxx/as6309/t6309.asm
@@ -0,0 +1,9 @@
+	.title	6309 Assembler Test
+
+	.sbttl	All 6309 Instructions
+
+;	to be continued
+
+	bitmd	#0x78		;11 3C 78
+
+;	to be continued
diff --git a/asxv5pxx/as6809/m09mch.c b/asxv5pxx/as6809/m09mch.c
index 6710bca..7ac6773 100644
--- a/asxv5pxx/as6809/m09mch.c
+++ b/asxv5pxx/as6809/m09mch.c
@@ -151,11 +151,13 @@ static char m09idx[32] = {
 /*   ---	*/	0,	/*  [n]		*/	5
 };
 
+#if	!M6809STRICT
 static char m00cyc[24] = {
 	12,12, 3, 3, 3, 5, 5, 5,
 	 5, 6, 6, 6, 6,12, 3, 3,
 	 3, 8, 6, 8, 6, 6, 6,20
 };
+#endif
 
 
 /*
@@ -331,10 +333,12 @@ struct mne *mp;
 		aerr();
 		break;
 
+#if	!M6809STRICT
 	case S_6800:
 		m68out(op);
 		opcycles = m00cyc[op];
 		break;
+#endif
 
 	default:
 		opcycles = OPCY_ERR;
@@ -545,6 +549,7 @@ struct expr *esp;
 /*
  * mc6800 compatibility output routine
  */
+#if	!M6809STRICT
 VOID
 m68out(i)
 int i;
@@ -561,6 +566,7 @@ int i;
 		}
 	}
 }
+#endif
 
 /*
  * Branch/Jump PCR Mode Check
diff --git a/asxv5pxx/as6809/m09pst.c b/asxv5pxx/as6809/m09pst.c
index b57495a..4765028 100644
--- a/asxv5pxx/as6809/m09pst.c
+++ b/asxv5pxx/as6809/m09pst.c
@@ -226,6 +226,7 @@ struct	mne	mne[] = {
 
 	/* 6800 Compatibility */
 
+#if	!M6809STRICT
     {	NULL,	"ldaa",		S_ACC,		0,	0x86	},
     {	NULL,	"ldab",		S_ACC,		0,	0xC6	},
     {	NULL,	"oraa",		S_ACC,		0,	0x8A	},
@@ -259,6 +260,7 @@ struct	mne	mne[] = {
     {	NULL,	"tsx",		S_6800,		0,	21	},
     {	NULL,	"txs",		S_6800,		0,	22	},
     {	NULL,	"wai",		S_6800,		0,	23	},
+#endif
 
 	/* 6809 */
 
@@ -283,7 +285,9 @@ struct	mne	mne[] = {
     {	NULL,	"subd",		S_LR,		0,	0x83	},
     {	NULL,	"addd",		S_LR,		0,	0xC3	},
     {	NULL,	"cmpx",		S_LR,		0,	0x8C	},
+#if	!M6809STRICT
     {	NULL,	"cpx",		S_LR,		0,	0x8C	},
+#endif
     {	NULL,	"ldd",		S_LR,		0,	0xCC	},
     {	NULL,	"ldx",		S_LR,		0,	0x8E	},
     {	NULL,	"ldu",		S_LR,		0,	0xCE	},
@@ -307,7 +311,9 @@ struct	mne	mne[] = {
 
     {	NULL,	"swi3",		S_INH2,		0,	0x3F	},
     {	NULL,	"swi2",		S_INH1,		0,	0x3F	},
+#if	!M6809STRICT
     {	NULL,	"swi1",		S_INH,		0,	0x3F	},
+#endif
 
     {	NULL,	"abx",		S_INH,		0,	0x3A	},
     {	NULL,	"asla",		S_INH,		0,	0x48	},
@@ -346,10 +352,14 @@ struct	mne	mne[] = {
     {	NULL,	"lbrn",		S_LBRA,		0,	0x21	},
     {	NULL,	"lbhi",		S_LBRA,		0,	0x22	},
     {	NULL,	"lbls",		S_LBRA,		0,	0x23	},
+#if	!M6809STRICT
     {	NULL,	"lblos",	S_LBRA,		0,	0x23	},
+#endif
     {	NULL,	"lbcc",		S_LBRA,		0,	0x24	},
     {	NULL,	"lbhs",		S_LBRA,		0,	0x24	},
+#if	!M6809STRICT
     {	NULL,	"lbhis",	S_LBRA,		0,	0x24	},
+#endif
     {	NULL,	"lbcs",		S_LBRA,		0,	0x25	},
     {	NULL,	"lblo",		S_LBRA,		0,	0x25	},
     {	NULL,	"lbne",		S_LBRA,		0,	0x26	},
@@ -405,10 +415,14 @@ struct	mne	mne[] = {
     {	NULL,	"brn",		S_BRA,		0,	0x21	},
     {	NULL,	"bhi",		S_BRA,		0,	0x22	},
     {	NULL,	"bls",		S_BRA,		0,	0x23	},
+#if	!M6809STRICT
     {	NULL,	"blos",		S_BRA,		0,	0x23	},
+#endif
     {	NULL,	"bcc",		S_BRA,		0,	0x24	},
     {	NULL,	"bhs",		S_BRA,		0,	0x24	},
+#if	!M6809STRICT
     {	NULL,	"bhis",		S_BRA,		0,	0x24	},
+#endif
     {	NULL,	"bcs",		S_BRA,		0,	0x25	},
     {	NULL,	"blo",		S_BRA,		0,	0x25	},
     {	NULL,	"bne",		S_BRA,		0,	0x26	},
@@ -424,6 +438,7 @@ struct	mne	mne[] = {
     {	NULL,	"bsr",		S_BRA,		S_EOL,	0x8D	}
 };
 
+#if	!M6809STRICT
 struct opdata mc6800[] = {
 
     {{	(char) 0x34, (char) 0x04,	/*	pshs	b	;aba	*/
@@ -498,3 +513,4 @@ struct opdata mc6800[] = {
     {{	(char) 0x3c, (char) 0xff,	/*	cwai	#0xFF	;wai	*/
 	(char) 0x00, (char) 0x00	}}
 };
+#endif
diff --git a/asxv5pxx/as6809/m6809.h b/asxv5pxx/as6809/m6809.h
index ff786e4..b0f8be7 100644
--- a/asxv5pxx/as6809/m6809.h
+++ b/asxv5pxx/as6809/m6809.h
@@ -90,7 +90,9 @@
 /*
  * 6800 Instruction types
  */
+#if	!M6809STRICT
 #define	S_6800	70
+#endif
 
 /*
  * Set Direct Pointer
@@ -127,7 +129,9 @@ struct opdata
 	char	opcode[4];	/* byte data */
 };
 
+#if	!M6809STRICT
 extern struct opdata mc6800[];
+#endif
 
 
 	/* machine dependent functions */
diff --git a/asxv5pxx/asxmak/cygwin/build/makefile b/asxv5pxx/asxmak/cygwin/build/makefile
index 9e1b0f4..f9beff2 100644
--- a/asxv5pxx/asxmak/cygwin/build/makefile
+++ b/asxv5pxx/asxmak/cygwin/build/makefile
@@ -45,6 +45,7 @@ ASXXXX =	as1802		\
 		asz8		\
 		asz80		\
 		aslink		\
+		aslib		\
 		asxscn		\
 		asxcnv		\
 		s19os9
@@ -55,10 +56,10 @@ ASXXXX =	as1802		\
 
 CC=		gcc
 CCOPT=		-O3
-CCFLAGS=	-Wall -funsigned-char $(CCOPT)
+CCFLAGS=	-Wall -funsigned-char $(CCOPT) $(EXTRA_ASXXXX_CFLAGS)
 
 LD=		gcc
-LDFLAGS=	-Wall
+LDFLAGS=	-Wall $(EXTRA_ASXXXX_CFLAGS)
 
 
 ####################################################################
@@ -71,6 +72,7 @@ ASXBAS=		../../../
 
 SRCASX=		$(ASXBAS)asxxsrc/
 SRCLNK=		$(ASXBAS)linksrc/
+SRCLIB=		$(ASXBAS)libsrc/
 SRCMISC=	$(ASXBAS)asxxmisc/
 SRCS19OS9=	$(ASXBAS)s19os9/
 DSTEXE=		../exe/
@@ -903,11 +905,28 @@ lkout.o  :	$(SRCLNK)lkout.c  $(SRCLNK)aslink.h
 		$(CC) $(CCFLAGS) -I$(SRCMISC) -c $< -o $(@F)
 
 aslink :	$(ASLINK)
-		$(LD) $(LDFLAGS) -o aslink $(ASLINK)
+		$(LD) $(LDFLAGS) $(ASLINK) $(EXTRA_ASXXXX_LDFLAGS) -o aslink
 		cp aslink.exe $(DSTEXE)aslink.exe
 		strip $(DSTEXE)aslink.exe
 
 
+####################################################################
+# ASLIB
+####################################################################
+
+ASLIB =		armain.o ardata.o
+
+armain.o :	$(SRCLIB)armain.c $(SRCLIB)common.c $(SRCLIB)aslib.h
+		$(CC) $(CCFLAGS) -I$(SRCMISC) -c $< -o $(@F)
+ardata.o :	$(SRCLIB)ardata.c $(SRCLIB)common.c $(SRCLIB)aslib.h
+		$(CC) $(CCFLAGS) -I$(SRCMISC) -c $< -o $(@F)
+
+aslib :		$(ASLIB)
+		$(LD) $(LDFLAGS) $(ASLIB) $(EXTRA_ASXXXX_LDFLAGS) -o aslib
+		cp aslib.exe $(DSTEXE)aslib.exe
+		strip $(DSTEXE)aslib.exe
+
+
 ####################################################################
 # ASXCNV
 ####################################################################
@@ -953,4 +972,4 @@ s19os9 :	$(S19OS9)
 		strip $(DSTEXE)s19os9.exe
 
 
-### end #########################################################
+### end ############################################################
diff --git a/asxv5pxx/asxmak/darwin/build/makefile b/asxv5pxx/asxmak/darwin/build/makefile
new file mode 100644
index 0000000..37f80b6
--- /dev/null
+++ b/asxv5pxx/asxmak/darwin/build/makefile
@@ -0,0 +1,1000 @@
+######################################################################
+#  Makefile
+#		DARWIN Version
+#		==============
+#
+#   8 October 2014			Created for DARWIN    / make /
+#
+######################################################################
+
+.PHONY:	all clean prep
+
+all:	as1802		\
+	as2650		\
+	as430		\
+	as6100		\
+	as61860		\
+	as6500		\
+	as6800		\
+	as6801		\
+	as6804		\
+	as6805		\
+	as6808		\
+	as6809		\
+	as6811		\
+	as6812		\
+	as6816		\
+	as740		\
+	as78k0s		\
+	as8048		\
+	as8051		\
+	as8085		\
+	as8xcxxx	\
+	asavr		\
+	asez80		\
+	asf2mc8		\
+	asf8		\
+	asgb		\
+	ash8		\
+	asm8c		\
+	aspic		\
+	asrab		\
+	asscmp		\
+	ascheck		\
+	asst6		\
+	asst7		\
+	asst8		\
+	asz8		\
+	asz80		\
+	aslink		\
+	aslib		\
+	asxscn		\
+	asxcnv		\
+	s19os9
+
+clean:
+	rm -f $(SRCASX)*.o
+	rm -f $(SRCLNK)*.o
+	rm -f $(SRCLIB)*.o
+	rm -f $(SRCMISC)*.o
+	rm -f $(S19OS9)*.o
+	rm -f $(SRC1802)*.o
+	rm -f $(SRC2650)*.o
+	rm -f $(SRC430)*.o
+	rm -f $(SRC6100)*.o
+	rm -f $(SRC61860)*.o
+	rm -f $(SRC6500)*.o
+	rm -f $(SRC6800)*.o
+	rm -f $(SRC6801)*.o
+	rm -f $(SRC6804)*.o
+	rm -f $(SRC6805)*.o
+	rm -f $(SRC6808)*.o
+	rm -f $(SRC6809)*.o
+	rm -f $(SRC6811)*.o
+	rm -f $(SRC6812)*.o
+	rm -f $(SRC6816)*.o
+	rm -f $(SRC740)*.o
+	rm -f $(SRC78K0S)*.o
+	rm -f $(SRC8048)*.o
+	rm -f $(SRC8051)*.o
+	rm -f $(SRC8085)*.o
+	rm -f $(SRC8XCXXX)*.o
+	rm -f $(SRCAVR)*.o
+	rm -f $(SRCCHECK)*.o
+	rm -f $(SRCEZ80)*.o
+	rm -f $(SRCF2MC8)*.o
+	rm -f $(SRCF8)*.o
+	rm -f $(SRCGB)*.o
+	rm -f $(SRCH8)*.o
+	rm -f $(SRCM8C)*.o
+	rm -f $(SRCPIC)*.o
+	rm -f $(SRCRAB)*.o
+	rm -f $(SRCSCMP)*.o
+	rm -f $(SRCST6)*.o
+	rm -f $(SRCST7)*.o
+	rm -f $(SRCST8)*.o
+	rm -f $(SRCZ8)*.o
+	rm -f $(SRCZ80)*.o
+	rm -f as1802
+	rm -f as2650
+	rm -f as430
+	rm -f as6100
+	rm -f as61860
+	rm -f as6500
+	rm -f as6800
+	rm -f as6801
+	rm -f as6804
+	rm -f as6805
+	rm -f as6808
+	rm -f as6809
+	rm -f as6811
+	rm -f as6812
+	rm -f as6816
+	rm -f as740
+	rm -f as78k0s
+	rm -f as8048
+	rm -f as8051
+	rm -f as8085
+	rm -f as8xcxxx
+	rm -f asavr
+	rm -f asez80
+	rm -f asf2mc8
+	rm -f asf8
+	rm -f asgb
+	rm -f ash8
+	rm -f asm8c
+	rm -f aspic
+	rm -f asrab
+	rm -f asscmp
+	rm -f ascheck
+	rm -f asst6
+	rm -f asst7
+	rm -f asst8
+	rm -f asz8
+	rm -f asz80
+	rm -f aslink
+	rm -f aslib
+	rm -f asxscn
+	rm -f asxcnv
+	rm -f s19os9
+	rm -f $(DSTEXE)*
+
+prep:
+	rm -f $(SRCASX)*.o
+	rm -f $(SRCLNK)*.o
+	rm -f $(SRCLIB)*.o
+	rm -f $(SRCMISC)*.o
+	rm -f $(S19OS9)*.o
+	rm -f $(SRC1802)*.o
+	rm -f $(SRC2650)*.o
+	rm -f $(SRC430)*.o
+	rm -f $(SRC6100)*.o
+	rm -f $(SRC61860)*.o
+	rm -f $(SRC6500)*.o
+	rm -f $(SRC6800)*.o
+	rm -f $(SRC6801)*.o
+	rm -f $(SRC6804)*.o
+	rm -f $(SRC6805)*.o
+	rm -f $(SRC6808)*.o
+	rm -f $(SRC6809)*.o
+	rm -f $(SRC6811)*.o
+	rm -f $(SRC6812)*.o
+	rm -f $(SRC6816)*.o
+	rm -f $(SRC740)*.o
+	rm -f $(SRC78K0S)*.o
+	rm -f $(SRC8048)*.o
+	rm -f $(SRC8051)*.o
+	rm -f $(SRC8085)*.o
+	rm -f $(SRC8XCXXX)*.o
+	rm -f $(SRCAVR)*.o
+	rm -f $(SRCCHECK)*.o
+	rm -f $(SRCEZ80)*.o
+	rm -f $(SRCF2MC8)*.o
+	rm -f $(SRCF8)*.o
+	rm -f $(SRCGB)*.o
+	rm -f $(SRCH8)*.o
+	rm -f $(SRCM8C)*.o
+	rm -f $(SRCPIC)*.o
+	rm -f $(SRCRAB)*.o
+	rm -f $(SRCSCMP)*.o
+	rm -f $(SRCST6)*.o
+	rm -f $(SRCST7)*.o
+	rm -f $(SRCST8)*.o
+	rm -f $(SRCZ8)*.o
+	rm -f $(SRCZ80)*.o
+	rm -f as1802
+	rm -f as2650
+	rm -f as430
+	rm -f as6100
+	rm -f as61860
+	rm -f as6500
+	rm -f as6800
+	rm -f as6801
+	rm -f as6804
+	rm -f as6805
+	rm -f as6808
+	rm -f as6809
+	rm -f as6811
+	rm -f as6812
+	rm -f as6816
+	rm -f as740
+	rm -f as78k0s
+	rm -f as8048
+	rm -f as8051
+	rm -f as8085
+	rm -f as8xcxxx
+	rm -f asavr
+	rm -f asez80
+	rm -f asf2mc8
+	rm -f asf8
+	rm -f asgb
+	rm -f ash8
+	rm -f asm8c
+	rm -f aspic
+	rm -f asrab
+	rm -f asscmp
+	rm -f ascheck
+	rm -f asst6
+	rm -f asst7
+	rm -f asst8
+	rm -f asz8
+	rm -f asz80
+	rm -f aslink
+	rm -f aslib
+	rm -f asxscn
+	rm -f asxcnv
+	rm -f s19os9
+
+
+CC=		gcc
+CCOPT=		-O3
+CCFLAGS=	-Wall -funsigned-char $(CCOPT) $(EXTRA_ASXXXX_CFLAGS)
+
+LD=		gcc
+LDFLAGS=	-Wall $(EXTRA_ASXXXX_CFLAGS)
+
+#  Set ASXBAS relative to this make file.
+
+ASXBAS:=	../../../
+
+SRCASX:=	$(ASXBAS)asxxsrc/
+SRCLNK:=	$(ASXBAS)linksrc/
+SRCLIB:=	$(ASXBAS)libsrc/
+SRCMISC:=	$(ASXBAS)asxxmisc/
+SRCS19OS9:=	$(ASXBAS)s19os9/
+DSTEXE:=	$(ASXBAS)asxmak/darwin/exe/
+
+SRC1802=	$(ASXBAS)as1802/
+SRC2650=	$(ASXBAS)as2650/
+SRC430=		$(ASXBAS)as430/
+SRC6100=	$(ASXBAS)as6100/
+SRC61860=	$(ASXBAS)as61860/
+SRC6500=	$(ASXBAS)as6500/
+SRC6800=	$(ASXBAS)as6800/
+SRC6801=	$(ASXBAS)as6801/
+SRC6804=	$(ASXBAS)as6804/
+SRC6805=	$(ASXBAS)as6805/
+SRC6808=	$(ASXBAS)as6808/
+SRC6809=	$(ASXBAS)as6809/
+SRC6811=	$(ASXBAS)as6811/
+SRC6812=	$(ASXBAS)as6812/
+SRC6816=	$(ASXBAS)as6816/
+SRC740=		$(ASXBAS)as740/
+SRC78K0S=	$(ASXBAS)as78k0s/
+SRC8048=	$(ASXBAS)as8048/
+SRC8051=	$(ASXBAS)as8051/
+SRC8085=	$(ASXBAS)as8085/
+SRC8XCXXX=	$(ASXBAS)as8xcxxx/
+SRCAVR=		$(ASXBAS)asavr/
+SRCCHECK=	$(ASXBAS)ascheck/
+SRCEZ80=	$(ASXBAS)asez80/
+SRCF2MC8=	$(ASXBAS)asf2mc8/
+SRCF8=		$(ASXBAS)asf8/
+SRCGB=		$(ASXBAS)asgb/
+SRCH8=		$(ASXBAS)ash8/
+SRCM8C=		$(ASXBAS)asm8c/
+SRCPIC=		$(ASXBAS)aspic/
+SRCRAB=		$(ASXBAS)asrab/
+SRCSCMP=	$(ASXBAS)asscmp/
+SRCST6=		$(ASXBAS)asst6/
+SRCST7=		$(ASXBAS)asst7/
+SRCST8=		$(ASXBAS)asst8/
+SRCZ8=		$(ASXBAS)asz8/
+SRCZ80=		$(ASXBAS)asz80/
+
+.SUFFIXES:	.c .o
+
+%.o: %.c
+	$(CC) $(CCFLAGS) -I$(SRCMISC) -I$(SRCASX) -c $< -o $@
+
+
+ASXX =	asdata.o asexpr.o aslex.o aslist.o	\
+	asmain.o asmcro.o asout.o assubr.o	\
+	assym.o	asdbg.o
+
+ASXXSRC =	$(addprefix $(SRCASX),$(ASXX))
+
+$(ASXXSRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h
+
+
+####################################################################
+# AS1802
+####################################################################
+
+AS1802 =	1802mch.o 1802pst.o
+
+AS1802SRC =	$(addprefix $(SRC1802),$(AS1802))
+
+$(AS1802SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC1802)1802.h
+
+as1802:	$(ASXXSRC) $(AS1802SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS1802SRC) -o as1802
+	cp as1802 $(DSTEXE)as1802
+	strip $(DSTEXE)as1802
+	chmod 755 $(DSTEXE)as1802
+
+
+####################################################################
+# AS2650
+####################################################################
+
+AS2650 =	s26adr.o s26mch.o s26pst.o
+
+AS2650SRC =	$(addprefix $(SRC2650),$(AS2650))
+
+$(AS2650SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC2650)s2650.h
+
+as2650:	$(ASXXSRC) $(AS2650SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS2650SRC) -o as2650
+	cp as2650 $(DSTEXE)as2650
+	strip $(DSTEXE)as2650
+	chmod 755 $(DSTEXE)as2650
+
+
+####################################################################
+# AS430
+####################################################################
+
+AS430 =		m430adr.o m430mch.o m430pst.o
+
+AS430SRC =	$(addprefix $(SRC430),$(AS430))
+
+$(AS430SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC430)m430.h
+
+as430:	$(ASXXSRC) $(AS430SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS430SRC) -o as430
+	cp as430 $(DSTEXE)as430
+	strip $(DSTEXE)as430
+	chmod 755 $(DSTEXE)as430
+
+####################################################################
+# AS6100
+####################################################################
+
+AS6100 =	i61adr.o i61mch.o i61pst.o
+
+AS6100SRC =	$(addprefix $(SRC6100),$(AS6100))
+
+$(AS6100SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC6100)i6100.h
+
+as6100:	$(ASXXSRC) $(AS6100SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS6100SRC) -o as6100
+	cp as6100 $(DSTEXE)as6100
+	strip $(DSTEXE)as6100
+	chmod 755 $(DSTEXE)as6100
+
+####################################################################
+# AS61860
+####################################################################
+
+AS61860 =	s6186adr.o s6186mch.o s6186pst.o
+
+AS61860SRC =	$(addprefix $(SRC61860),$(AS61860))
+
+$(AS61860SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC61860)s61860.h
+
+as61860:	$(ASXXSRC) $(AS61860SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS61860SRC) -o as61860
+	cp as61860 $(DSTEXE)as61860
+	strip $(DSTEXE)as61860
+	chmod 755 $(DSTEXE)as61860
+
+
+####################################################################
+# AS6500
+####################################################################
+
+AS6500 =	r65adr.o r65mch.o r65pst.o
+
+AS6500SRC =	$(addprefix $(SRC6500),$(AS6500))
+
+$(AS6500SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC6500)r6500.h
+
+as6500:	$(ASXXSRC) $(AS6500SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS6500SRC) -o as6500
+	cp as6500 $(DSTEXE)as6500
+	strip $(DSTEXE)as6500
+	chmod 755 $(DSTEXE)as6500
+
+
+####################################################################
+# AS6800
+####################################################################
+
+AS6800 =	m00adr.o m00mch.o m00pst.o
+
+AS6800SRC =	$(addprefix $(SRC6800),$(AS6800))
+
+$(AS6800SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC6800)m6800.h
+
+as6800:	$(ASXXSRC) $(AS6800SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS6800SRC) -o as6800
+	cp as6800 $(DSTEXE)as6800
+	strip $(DSTEXE)as6800
+	chmod 755 $(DSTEXE)as6800
+
+
+####################################################################
+# AS6801
+####################################################################
+
+AS6801 =	m01adr.o m01mch.o m01pst.o
+
+AS6801SRC =	$(addprefix $(SRC6801),$(AS6801))
+
+$(AS6801SRC):	 $(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC6801)m6801.h
+
+as6801:	$(ASXXSRC) $(AS6801SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS6801SRC) -o as6801
+	cp as6801 $(DSTEXE)as6801
+	strip $(DSTEXE)as6801
+	chmod 755 $(DSTEXE)as6801
+
+
+####################################################################
+# AS6804
+####################################################################
+
+AS6804 =	m04adr.o m04mch.o m04pst.o
+
+AS6804SRC =	$(addprefix $(SRC6804),$(AS6804))
+
+$(AS6804SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC6804)m6804.h
+
+as6804:	$(ASXXSRC) $(AS6804SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS6804SRC) -o as6804
+	cp as6804 $(DSTEXE)as6804
+	strip $(DSTEXE)as6804
+	chmod 755 $(DSTEXE)as6804
+
+
+####################################################################
+# AS6805
+####################################################################
+
+AS6805 =	m05adr.o m05mch.o m05pst.o
+
+AS6805SRC =	$(addprefix $(SRC6805),$(AS6805))
+
+$(AS6805SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC6805)m6805.h
+
+as6805:	$(ASXXSRC) $(AS6805SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS6805SRC) -o as6805
+	cp as6805 $(DSTEXE)as6805
+	strip $(DSTEXE)as6805
+	chmod 755 $(DSTEXE)as6805
+
+
+####################################################################
+# AS6808
+####################################################################
+
+AS6808 =	m08adr.o m08mch.o m08pst.o
+
+AS6808SRC =	$(addprefix $(SRC6808),$(AS6808))
+
+$(AS6808SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC6808)m6808.h
+
+as6808:	$(ASXXSRC) $(AS6808SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS6808SRC) -o as6808
+	cp as6808 $(DSTEXE)as6808
+	strip $(DSTEXE)as6808
+	chmod 755 $(DSTEXE)as6808
+
+
+####################################################################
+# AS6809
+####################################################################
+
+AS6809 =	m09adr.o m09mch.o m09pst.o
+
+AS6809SRC =	$(addprefix $(SRC6809),$(AS6809))
+
+$(AS6809SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC6809)m6809.h
+
+as6809:	$(ASXXSRC) $(AS6809SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS6809SRC) -o as6809
+	cp as6809 $(DSTEXE)as6809
+	strip $(DSTEXE)as6809
+	chmod 755 $(DSTEXE)as6809
+
+
+####################################################################
+# AS6811
+####################################################################
+
+AS6811 =	m11adr.o m11mch.o m11pst.o
+
+AS6811SRC =	$(addprefix $(SRC6811),$(AS6811))
+
+$(AS6811SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC6811)m6811.h
+
+as6811:	$(ASXXSRC) $(AS6811SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS6811SRC) -o as6811
+	cp as6811 $(DSTEXE)as6811
+	strip $(DSTEXE)as6811
+	chmod 755 $(DSTEXE)as6811
+
+
+####################################################################
+# AS6812
+####################################################################
+
+AS6812 =	m12adr.o m12mch.o m12pst.o
+
+AS6812SRC =	$(addprefix $(SRC6812),$(AS6812))
+
+$(AS6812SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC6812)m6812.h
+
+as6812:	$(ASXXSRC) $(AS6812SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS6812SRC) -o as6812
+	cp as6812 $(DSTEXE)as6812
+	strip $(DSTEXE)as6812
+	chmod 755 $(DSTEXE)as6812
+
+
+####################################################################
+# AS6816
+####################################################################
+
+AS6816 =	m16adr.o m16mch.o m16pst.o
+
+AS6816SRC =	$(addprefix $(SRC6816),$(AS6816))
+
+$(AS6816SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC6816)m6816.h
+
+as6816:	$(ASXXSRC) $(AS6816SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS6816SRC) -o as6816
+	cp as6816 $(DSTEXE)as6816
+	strip $(DSTEXE)as6816
+	chmod 755 $(DSTEXE)as6816
+
+
+####################################################################
+# AS740
+####################################################################
+
+AS740 =		m74adr.o m74mch.o m74pst.o
+
+AS740SRC =	$(addprefix $(SRC740),$(AS740))
+
+$(AS740SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC740)m740.h
+
+as740:	$(ASXXSRC) $(AS740SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS740SRC) -o as740
+	cp as740 $(DSTEXE)as740
+	strip $(DSTEXE)as740
+	chmod 755 $(DSTEXE)as740
+
+
+####################################################################
+# AS78K0S
+####################################################################
+
+AS78K0S =	r78kadr.o r78kmch.o r78kpst.o
+
+AS78KSRC =	$(addprefix $(SRC78K0S),$(AS78K0S))
+
+$(AS78KSRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC78K0S)r78k0s.h
+
+as78k0s:	$(ASXXSRC) $(AS78KSRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS78KSRC) -o as78k0s
+	cp as78k0s $(DSTEXE)as78k0s
+	strip $(DSTEXE)as78k0s
+	chmod 755 $(DSTEXE)as78k0s
+
+
+####################################################################
+# AS8048
+####################################################################
+
+AS8048 =	i48adr.o i48mch.o i48pst.o
+
+AS8048SRC =	$(addprefix $(SRC8048),$(AS8048))
+
+$(AS8048SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC8048)i8048.h
+
+as8048:	$(ASXXSRC) $(AS8048SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS8048SRC) -o as8048
+	cp as8048 $(DSTEXE)as8048
+	strip $(DSTEXE)as8048
+	chmod 755 $(DSTEXE)as8048
+
+
+####################################################################
+# AS8051
+####################################################################
+
+AS8051 =	i51adr.o i51mch.o i51pst.o
+
+AS8051SRC =	$(addprefix $(SRC8051),$(AS8051))
+
+$(AS8051SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC8051)i8051.h
+
+as8051:	$(ASXXSRC) $(AS8051SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS8051SRC) -o as8051
+	cp as8051 $(DSTEXE)as8051
+	strip $(DSTEXE)as8051
+	chmod 755 $(DSTEXE)as8051
+
+
+####################################################################
+# AS8085
+####################################################################
+
+AS8085 =	i85mch.o i85pst.o
+
+AS8085SRC =	$(addprefix $(SRC8085),$(AS8085))
+
+$(AS8085SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC8085)i8085.h
+
+as8085:	$(ASXXSRC) $(AS8085SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS8085SRC) -o as8085
+	cp as8085 $(DSTEXE)as8085
+	strip $(DSTEXE)as8085
+	chmod 755 $(DSTEXE)as8085
+
+
+####################################################################
+# AS8xcxxx
+####################################################################
+
+AS8XCXXX =	ds8adr.o ds8mch.o ds8pst.o
+
+AS8XCXXXSRC =	$(addprefix $(SRC8XCXXX),$(AS8XCXXX))
+
+$(AS8XCXXXSRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRC8XCXXX)ds8.h
+
+as8xcxxx:	$(ASXXSRC) $(AS8XCXXXSRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(AS8XCXXXSRC) -o as8xcxxx
+	cp as8xcxxx $(DSTEXE)as8xcxxx
+	strip $(DSTEXE)as8xcxxx
+	chmod 755 $(DSTEXE)as8xcxxx
+
+
+####################################################################
+# ASAVR
+####################################################################
+
+ASAVR =		avradr.o avrmch.o avrpst.o
+
+ASAVRSRC =	$(addprefix $(SRCAVR),$(ASAVR))
+
+$(ASAVRSRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCAVR)avr.h
+
+asavr:	$(ASXXSRC) $(ASAVRSRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASAVRSRC) -o asavr
+	cp asavr $(DSTEXE)asavr
+	strip $(DSTEXE)asavr
+	chmod 755 $(DSTEXE)asavr
+
+
+####################################################################
+# ASCHECK
+####################################################################
+
+ASCHECK =	chkadr.o chkmch.o chkpst.o
+
+ASCHECKSRC =	$(addprefix $(SRCCHECK),$(ASCHECK))
+
+$(ASCHECKSRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCCHECK)chk.h
+
+ascheck:	$(ASXXSRC) $(ASCHECKSRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASCHECKSRC) -o ascheck
+	cp ascheck $(DSTEXE)ascheck
+	strip $(DSTEXE)ascheck
+	chmod 755 $(DSTEXE)ascheck
+
+
+####################################################################
+# ASEZ80
+####################################################################
+
+ASEZ80 =	ez80adr.o ez80mch.o ez80pst.o
+
+ASEZ80SRC =	$(addprefix $(SRCEZ80),$(ASEZ80))
+
+$(ASEZ80SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCEZ80)ez80.h
+
+asez80:	$(ASXXSRC) $(ASEZ80SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASEZ80SRC) -o asez80
+	cp asez80 $(DSTEXE)asez80
+	strip $(DSTEXE)asez80
+	chmod 755 $(DSTEXE)asez80
+
+
+####################################################################
+# ASF2MC8
+####################################################################
+
+ASF2MC8 =	f2mc8adr.o f2mc8mch.o f2mc8pst.o
+
+ASF2MC8SRC =	$(addprefix $(SRCF2MC8),$(ASF2MC8))
+
+$(ASF2MC8SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCF2MC8)f2mc8.h
+
+asf2mc8:	$(ASXXSRC) $(ASF2MC8SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASF2MC8SRC) -o asf2mc8
+	cp asf2mc8 $(DSTEXE)asf2mc8
+	strip $(DSTEXE)asf2mc8
+	chmod 755 $(DSTEXE)asf2mc8
+
+
+####################################################################
+# ASF8
+####################################################################
+
+ASF8 =		f8adr.o f8mch.o f8pst.o
+
+ASF8SRC =	$(addprefix $(SRCF8),$(ASF8))
+
+$(ASF8SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCF8)f8.h
+
+asf8:	$(ASXXSRC) $(ASF8SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASF8SRC) -o asf8
+	cp asf8 $(DSTEXE)asf8
+	strip $(DSTEXE)asf8
+	chmod 755 $(DSTEXE)asf8
+
+
+####################################################################
+# ASGB
+####################################################################
+
+ASGB =		gbadr.o gbmch.o gbpst.o
+
+ASGBSRC =	$(addprefix $(SRCGB),$(ASGB))
+
+$(ASGBSRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCGB)gb.h
+
+asgb:	$(ASXXSRC) $(ASGBSRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASGBSRC) -o asgb
+	cp asgb $(DSTEXE)asgb
+	strip $(DSTEXE)asgb
+	chmod 755 $(DSTEXE)asgb
+
+
+####################################################################
+# ASH8
+####################################################################
+
+ASH8 =		h8adr.o h8mch.o h8pst.o
+
+ASH8SRC =	$(addprefix $(SRCH8),$(ASH8))
+
+$(ASH8SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCH8)h8.h
+
+ash8:	$(ASXXSRC) $(ASH8SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASH8SRC) -o ash8
+	cp ash8 $(DSTEXE)ash8
+	strip $(DSTEXE)ash8
+	chmod 755 $(DSTEXE)ash8
+
+
+####################################################################
+# ASM8C
+####################################################################
+
+ASM8C =		m8cadr.o m8cmch.o m8cpst.o
+
+ASM8CSRC =	$(addprefix $(SRCM8C),$(ASM8C))
+
+$(ASM8CSRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCM8C)m8c.h
+
+asm8c:	$(ASXXSRC) $(ASM8CSRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASM8CSRC) -o asm8c
+	cp asm8c $(DSTEXE)asm8c
+	strip $(DSTEXE)asm8c
+	chmod 755 $(DSTEXE)asm8c
+
+
+####################################################################
+# ASPIC
+####################################################################
+
+ASPIC =		picadr.o picmch.o picpst.o
+
+ASPICSRC =	$(addprefix $(SRCPIC),$(ASPIC))
+
+$(ASPICSRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCPIC)pic.h
+
+aspic:	$(ASXXSRC) $(ASPICSRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASPICSRC) -o aspic
+	cp aspic $(DSTEXE)aspic
+	strip $(DSTEXE)aspic
+	chmod 755 $(DSTEXE)aspic
+
+
+####################################################################
+# ASRAB
+####################################################################
+
+ASRAB =		rabadr.o rabmch.o rabpst.o
+
+ASRABSRC =	$(addprefix $(SRCRAB),$(ASRAB))
+
+$(ASRABSRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCRAB)rab.h
+
+asrab:	$(ASXXSRC) $(ASRABSRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASRABSRC) -o asrab
+	cp asrab $(DSTEXE)asrab
+	strip $(DSTEXE)asrab
+	chmod 755 $(DSTEXE)asrab
+
+
+####################################################################
+# ASSCMP
+####################################################################
+
+ASSCMP =	scmpadr.o scmpmch.o scmppst.o
+
+ASSCMPSRC =	$(addprefix $(SRCSCMP),$(ASSCMP))
+
+$(ASSCMPSRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCSCMP)scmp.h
+
+asscmp:	$(ASXXSRC) $(ASSCMPSRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASSCMPSRC) -o asscmp
+	cp asscmp $(DSTEXE)asscmp
+	strip $(DSTEXE)asscmp
+	chmod 755 $(DSTEXE)asscmp
+
+
+####################################################################
+# ASST6
+####################################################################
+
+ASST6 =		st6adr.o st6mch.o st6pst.o
+
+ASST6SRC =	$(addprefix $(SRCST6),$(ASST6))
+
+$(ASST6SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCST6)st6.h
+
+asst6:	$(ASXXSRC) $(ASST6SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASST6SRC) -o asst6
+	cp asst6 $(DSTEXE)asst6
+	strip $(DSTEXE)asst6
+	chmod 755 $(DSTEXE)asst6
+
+
+####################################################################
+# ASST7
+####################################################################
+
+ASST7 =		st7adr.o st7mch.o st7pst.o
+
+ASST7SRC =	$(addprefix $(SRCST7),$(ASST7))
+
+$(ASST7SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCST7)st7.h
+
+asst7:	$(ASXXSRC) $(ASST7SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASST7SRC) -o asst7
+	cp asst7 $(DSTEXE)asst7
+	strip $(DSTEXE)asst7
+	chmod 755 $(DSTEXE)asst7
+
+
+####################################################################
+# ASST8
+####################################################################
+
+ASST8 =		st8adr.o st8mch.o st8pst.o
+
+ASST8SRC =	$(addprefix $(SRCST8),$(ASST8))
+
+$(ASST8SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCST8)st8.h
+
+asst8:	$(ASXXSRC) $(ASST8SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASST8SRC) -o asst8
+	cp asst8 $(DSTEXE)asst8
+	strip $(DSTEXE)asst8
+	chmod 755 $(DSTEXE)asst8
+
+
+####################################################################
+# ASZ8
+####################################################################
+
+ASZ8 =		z8adr.o z8mch.o z8pst.o
+
+ASZ8SRC =	$(addprefix $(SRCZ8),$(ASZ8))
+
+$(ASZ8SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCZ8)z8.h
+
+asz8:	$(ASXXSRC) $(ASZ8SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASZ8SRC) -o asz8
+	cp asz8 $(DSTEXE)asz8
+	strip $(DSTEXE)asz8
+	chmod 755 $(DSTEXE)asz8
+
+
+####################################################################
+# ASZ80
+####################################################################
+
+ASZ80 =		z80adr.o z80mch.o z80pst.o
+
+ASZ80SRC =	$(addprefix $(SRCZ80),$(ASZ80))
+
+$(ASZ80SRC):	$(SRCMISC)alloc.h $(SRCASX)asxxxx.h $(SRCZ80)z80.h
+
+asz80:	$(ASXXSRC) $(ASZ80SRC)
+	$(LD) $(LDFLAGS) $(ASXXSRC) $(ASZ80SRC) -o asz80
+	cp asz80 $(DSTEXE)asz80
+	strip $(DSTEXE)asz80
+	chmod 755 $(DSTEXE)asz80
+
+
+####################################################################
+# ASLINK
+####################################################################
+
+ASLINK =	lkmain.o lkhead.o lkarea.o lkbank.o	\
+		lkdata.o lkeval.o lklex.o lklibr.o	\
+		lklist.o lkrloc.o lkrloc3.o lkrloc4.o	\
+		lksym.o lkout.o lknoice.o lksdcdb.o
+
+ASLINKSRC =	$(addprefix $(SRCLNK),$(ASLINK))
+
+$(ASLINK):	$(SRCMISC)alloc.h $(SRCLNK)aslink.h
+
+aslink:	$(ASLINKSRC)
+	$(LD) $(LDFLAGS) $(ASLINKSRC) $(EXTRA_ASXXXX_LDFLAGS) -o aslink
+	cp aslink $(DSTEXE)aslink
+	strip $(DSTEXE)aslink
+	chmod 755 $(DSTEXE)aslink
+
+
+####################################################################
+# ASLIB
+####################################################################
+
+ASLIB =		armain.o ardata.o
+
+ASLIBSRC =	$(addprefix $(SRCLIB),$(ASLIB))
+
+$(ASLIB):	$(SRCLIB)aslib.h $(SRCLIB)common.c
+
+aslib:	$(ASLIBSRC)
+	$(LD) $(LDFLAGS) $(ASLIBSRC) $(EXTRA_ASXXXX_LDFLAGS) -o aslib
+	cp aslib $(DSTEXE)aslib
+	strip $(DSTEXE)aslib
+	chmod 755 $(DSTEXE)aslib
+
+
+####################################################################
+# ASXCNV
+####################################################################
+
+$(SRCMISC)asxxconv.o:	$(SRCASX)asxxxx.h
+asxcnv:	$(SRCMISC)asxxconv.o
+	$(LD) $(LDFLAGS) $(SRCMISC)asxxconv.o -o asxcnv
+	cp asxcnv $(DSTEXE)asxcnv
+	strip $(DSTEXE)asxcnv
+	chmod 755 $(DSTEXE)asxcnv
+
+
+####################################################################
+# ASXSCN
+####################################################################
+
+$(SRCMISC)asxxscan.o:	$(SRCASX)asxxxx.h
+asxscn:	$(SRCMISC)asxxscan.o
+	$(LD) $(LDFLAGS) $(SRCMISC)asxxscan.o -o asxscn
+	cp asxscn $(DSTEXE)asxscn
+	strip $(DSTEXE)asxscn
+	chmod 755 $(DSTEXE)asxscn
+
+
+####################################################################
+# S19OS9
+####################################################################
+
+$(SRCS19OS9)s19os9.o:	$(SRCASX)asxxxx.h
+s19os9:	$(SRCS19OS9)s19os9.o
+	$(LD) $(LDFLAGS) $(SRCS19OS9)s19os9.o -o s19os9
+	cp s19os9 $(DSTEXE)s19os9
+	strip $(DSTEXE)s19os9
+	chmod 755 $(DSTEXE)s19os9
+
+
+### end ############################################################
diff --git a/asxv5pxx/asxmak/djgpp/build/makefile b/asxv5pxx/asxmak/djgpp/build/makefile
index e14196a..aef8dca 100644
--- a/asxv5pxx/asxmak/djgpp/build/makefile
+++ b/asxv5pxx/asxmak/djgpp/build/makefile
@@ -45,6 +45,7 @@ ASXXXX =	as1802		\
 		asz8		\
 		asz80		\
 		aslink		\
+		aslib		\
 		asxscn		\
 		asxcnv		\
 		s19os9
@@ -55,10 +56,10 @@ ASXXXX =	as1802		\
 
 CC=		gcc
 CCOPT=		-O3
-CCFLAGS=	-Wall -funsigned-char $(CCOPT)
+CCFLAGS=	-Wall -funsigned-char $(CCOPT) $(EXTRA_ASXXXX_CFLAGS)
 
 LD=		gcc
-LDFLAGS=	-Wall
+LDFLAGS=	-Wall $(EXTRA_ASXXXX_CFLAGS)
 
 
 ####################################################################
@@ -71,6 +72,7 @@ ASXBAS=		../../../
 
 SRCASX=		$(ASXBAS)asxxsrc/
 SRCLNK=		$(ASXBAS)linksrc/
+SRCLIB=		$(ASXBAS)libsrc/
 SRCMISC=	$(ASXBAS)asxxmisc/
 SRCS19OS9=	$(ASXBAS)s19os9/
 DSTEXE=		../exe/
@@ -903,11 +905,28 @@ lkout.o  :	$(SRCLNK)lkout.c  $(SRCLNK)aslink.h
 		$(CC) $(CCFLAGS) -I$(SRCMISC) -c $< -o $(@F)
 
 aslink :	$(ASLINK)
-		$(LD) $(LDFLAGS) -o aslink $(ASLINK)
+		$(LD) $(LDFLAGS) $(ASLINK) $(EXTRA_ASXXXX_LDFLAGS) -o aslink
 		mv aslink.exe $(DSTEXE)aslink.exe
 		strip $(DSTEXE)aslink.exe
 
 
+####################################################################
+# ASLIB
+####################################################################
+
+ASLIB =		armain.o ardata.o
+
+armain.o :	$(SRCLIB)armain.c $(SRCLIB)common.c $(SRCLIB)aslib.h
+		$(CC) $(CCFLAGS) -I$(SRCMISC) -c $< -o $(@F)
+ardata.o :	$(SRCLIB)ardata.c $(SRCLIB)common.c $(SRCLIB)aslib.h
+		$(CC) $(CCFLAGS) -I$(SRCMISC) -c $< -o $(@F)
+
+aslib :		$(ASLIB)
+		$(LD) $(LDFLAGS) $(ASLIB) $(EXTRA_ASXXXX_LDFLAGS) -o aslib
+		mv aslib.exe $(DSTEXE)aslib.exe
+		strip $(DSTEXE)aslib.exe
+
+
 ####################################################################
 # ASXCNV
 ####################################################################
@@ -953,4 +972,4 @@ s19os9 :	$(S19OS9)
 		strip $(DSTEXE)s19os9.exe
 
 
-### end #########################################################
+### end ############################################################
diff --git a/asxv5pxx/asxmak/linux/build/makefile b/asxv5pxx/asxmak/linux/build/makefile
index e7c1a56..df96b26 100644
--- a/asxv5pxx/asxmak/linux/build/makefile
+++ b/asxv5pxx/asxmak/linux/build/makefile
@@ -47,13 +47,15 @@ all:	as1802		\
 	asz8		\
 	asz80		\
 	aslink		\
+	aslib		\
 	asxscn		\
 	asxcnv		\
 	s19os9
-	
+
 clean:
 	rm -f $(SRCASX)*.o
 	rm -f $(SRCLNK)*.o
+	rm -f $(SRCLIB)*.o
 	rm -f $(SRCMISC)*.o
 	rm -f $(S19OS9)*.o
 	rm -f $(SRC1802)*.o
@@ -131,6 +133,7 @@ clean:
 	rm -f asz8
 	rm -f asz80
 	rm -f aslink
+	rm -f aslib
 	rm -f asxscn
 	rm -f asxcnv
 	rm -f s19os9
@@ -139,6 +142,7 @@ clean:
 prep:
 	rm -f $(SRCASX)*.o
 	rm -f $(SRCLNK)*.o
+	rm -f $(SRCLIB)*.o
 	rm -f $(SRCMISC)*.o
 	rm -f $(S19OS9)*.o
 	rm -f $(SRC1802)*.o
@@ -216,6 +220,7 @@ prep:
 	rm -f asz8
 	rm -f asz80
 	rm -f aslink
+	rm -f aslib
 	rm -f asxscn
 	rm -f asxcnv
 	rm -f s19os9
@@ -223,10 +228,10 @@ prep:
 
 CC=		gcc
 CCOPT=		-O3
-CCFLAGS=	-Wall -funsigned-char $(CCOPT)
+CCFLAGS=	-Wall -funsigned-char $(CCOPT) $(EXTRA_ASXXXX_CFLAGS)
 
 LD=		gcc
-LDFLAGS=	-Wall
+LDFLAGS=	-Wall $(EXTRA_ASXXXX_CFLAGS)
 
 #  Set ASXBAS relative to this make file.
 
@@ -234,6 +239,7 @@ ASXBAS:=	../../../
 
 SRCASX:=	$(ASXBAS)asxxsrc/
 SRCLNK:=	$(ASXBAS)linksrc/
+SRCLIB:=	$(ASXBAS)libsrc/
 SRCMISC:=	$(ASXBAS)asxxmisc/
 SRCS19OS9:=	$(ASXBAS)s19os9/
 DSTEXE:=	$(ASXBAS)asxmak/linux/exe/
@@ -932,12 +938,29 @@ ASLINKSRC =	$(addprefix $(SRCLNK),$(ASLINK))
 $(ASLINK):	$(SRCMISC)alloc.h $(SRCLNK)aslink.h
 
 aslink:	$(ASLINKSRC)
-	$(LD) $(LDFLAGS) $(ASLINKSRC) -o aslink
+	$(LD) $(LDFLAGS) $(ASLINKSRC) $(EXTRA_ASXXXX_LDFLAGS) -o aslink
 	cp aslink $(DSTEXE)aslink
 	strip $(DSTEXE)aslink
 	chmod 755 $(DSTEXE)aslink
 
 
+####################################################################
+# ASLIB
+####################################################################
+
+ASLIB =		armain.o ardata.o
+
+ASLIBSRC =	$(addprefix $(SRCLIB),$(ASLIB))
+
+$(ASLIB):	$(SRCLIB)aslib.h $(SRCLIB)common.c
+
+aslib:	$(ASLIBSRC)
+	$(LD) $(LDFLAGS) $(ASLIBSRC) $(EXTRA_ASXXXX_LDFLAGS) -o aslib
+	cp aslib $(DSTEXE)aslib
+	strip $(DSTEXE)aslib
+	chmod 755 $(DSTEXE)aslib
+
+
 ####################################################################
 # ASXCNV
 ####################################################################
@@ -975,5 +998,3 @@ s19os9:	$(SRCS19OS9)s19os9.o
 
 
 ### end ############################################################
-
-
diff --git a/asxv5pxx/asxxmisc/asxxconv.c b/asxv5pxx/asxxmisc/asxxconv.c
index 634d6c3..b6e1c15 100644
--- a/asxv5pxx/asxxmisc/asxxconv.c
+++ b/asxv5pxx/asxxmisc/asxxconv.c
@@ -115,8 +115,6 @@ char *argv[];
 	inpfil = 0;
 	aserr = 0;
 
-	fprintf(stdout, "\n");
-
 	for (i=1; i<argc; ++i) {
 		p = argv[i];
 		if (*p == '-') {
@@ -156,17 +154,17 @@ char *argv[];
 				}
 		} else {
 			if (++inpfil > 1) {
-				printf("\r\nToo many files.\r\n");
+				fprintf(stderr, "Too many files\n");
 				asexit(ER_FATAL);
 			}
 			nfp = fopen(p, "r");
 			if (nfp == NULL) {
-				printf("\r\nFile %s not found\r\n", p);
+				fprintf(stderr, "File %s not found\n", p);
 				asexit(ER_FATAL);
 			}
 			dfp = fopen("a.out", "w");
 			if (dfp == NULL) {
-				printf("\r\nFile a.out not opened\r\n");
+				fprintf(stderr, "File a.out not opened\n");
 				asexit(ER_FATAL);
 			}
 		}
@@ -502,7 +500,7 @@ char *usetxt[] = {
 	"  d    decimal listing",
 	"  q    octal   listing",
 	"  x    hex     listing (default)",
-        "  2    16-Bit  address (default)",
+	"  2    16-Bit  address (default)",
 	"  3    24-Bit  address",
 	"  4    32-Bit  address",
 	"",
@@ -535,11 +533,11 @@ VOID
 usage(n)
 int n;
 {
-	char   **dp;
+	char **dp;
 
-	fprintf(stderr, "\nASxxxx Assembler Listing Converter %s", VERSION);
-	fprintf(stderr, "\nCopyright (C) 2009  Alan R. Baldwin");
-	fprintf(stderr, "\nThis program comes with ABSOLUTELY NO WARRANTY.\n\n");
+	fprintf(stderr, "ASxxxx Assembler Listing Converter " VERSION "\n");
+	fprintf(stderr, "Copyright (C) " COPYRIGHT " Alan R. Baldwin\n");
+	fprintf(stderr, "This program comes with ABSOLUTELY NO WARRANTY.\n\n");
 	for (dp = usetxt; *dp; dp++)
 		fprintf(stderr, "%s\n", *dp);
 	asexit(n);
diff --git a/asxv5pxx/asxxmisc/asxxscan.c b/asxv5pxx/asxxmisc/asxxscan.c
index ff931fc..119cc9a 100644
--- a/asxv5pxx/asxxmisc/asxxscan.c
+++ b/asxv5pxx/asxxmisc/asxxscan.c
@@ -110,8 +110,6 @@ char *argv[];
 	vlines = 0;
 	aserr = 0;
 
-	printf("\n");
-
 	for (i=1; i<argc; ++i) {
 		p = argv[i];
 		if (*p == '-') {
@@ -156,14 +154,14 @@ char *argv[];
 				}
 		} else {
 			if (++inpfil > 1) {
-				printf("?ASXSCN-E-Too many input files\n\n");
+				fprintf(stderr, "Too many input files\n");
 				asexit(ER_FATAL);
 			}
 			sfp[0] = fopen(p, "r");
 			if (sfp[0] != NULL) {
 				strcpy(scfile, p);
 			} else {
-				printf("?ASXSCN-E-File %s not found\n\n", p);
+				fprintf(stderr, "File %s not found\n", p);
 				asexit(ER_FATAL);
 			}
 		}
@@ -315,7 +313,7 @@ loop:
 				case 1:
 					if (iflag) { break; }
 				case 2:
-					printf("''%s''\r\n", scline);
+					fprintf(stderr, "''%s''\n", scline);
 					aserr += 1;
 					goto loop;
 				}
@@ -325,9 +323,9 @@ loop:
 		}
 	}
 	if (vlines) {
-		printf("%d code error(s) found in file %s\n\n", aserr, scfile);
+		printf("%d code error(s) found in file %s\n", aserr, scfile);
 	} else {
-		printf("?ASXSCN-E-Invalid File Format\n\n");
+		fprintf(stderr,"Invalid File Format\n");
 		aserr += 1;
 	}
 	asexit(aserr ? ER_ERROR : ER_NONE);
@@ -459,7 +457,7 @@ char *usetxt[] = {
 	"  d    decimal listing",
 	"  q    octal   listing",
 	"  x    hex     listing (default)",
-        "  2    16-Bit  address (default)",
+	"  2    16-Bit  address (default)",
 	"  3    24-Bit  address",
 	"  4    32-Bit  address",
 	"  i    ignore relocation flags",
@@ -495,9 +493,9 @@ int n;
 {
 	char **dp;
 
-	fprintf(stderr, "\nASxxxx Assembler Listing Scanner %s", VERSION);
-	fprintf(stderr, "\nCopyright (C) 2009  Alan R. Baldwin");
-	fprintf(stderr, "\nThis program comes with ABSOLUTELY NO WARRANTY.\n\n");
+	fprintf(stderr, "ASxxxx Assembler Listing Scanner " VERSION "\n");
+	fprintf(stderr, "Copyright (C) " COPYRIGHT " Alan R. Baldwin\n");
+	fprintf(stderr, "This program comes with ABSOLUTELY NO WARRANTY.\n\n");
 	for (dp = usetxt; *dp; dp++)
 		fprintf(stderr, "%s\n", *dp);
 	asexit(n);
diff --git a/asxv5pxx/asxxsrc/asdata.c b/asxv5pxx/asxxsrc/asdata.c
index 451a4fb..43bcf54 100644
--- a/asxv5pxx/asxxsrc/asdata.c
+++ b/asxv5pxx/asxxsrc/asdata.c
@@ -231,7 +231,7 @@ int	fflag;		/*	-f(f), relocations flagged flag
 			 */
 int	gflag;		/*	-g, make undefined symbols global flag
 			 */
-			/*	-h, diagnostic help printout flag
+			/*	-h, usage help listed
 			 */
 int	jflag;		/*	-j, enable NoICE Debug Symbols
 			 */
diff --git a/asxv5pxx/asxxsrc/asexpr.c b/asxv5pxx/asxxsrc/asexpr.c
index baf061c..f43450f 100644
--- a/asxv5pxx/asxxsrc/asexpr.c
+++ b/asxv5pxx/asxxsrc/asexpr.c
@@ -757,7 +757,7 @@ struct expr *esp;
  *		arithmetic overflow cannot be determined.
  *		This ambiguity is caused by the inability
  *		to distinguish signed and unsigned values
- *		at the instrinsic sizeof(int) size. 
+ *		at the instrinsic sizeof(int) size.
  */
 
 a_uint
diff --git a/asxv5pxx/asxxsrc/aslex.c b/asxv5pxx/asxxsrc/aslex.c
index fb887f9..b185a94 100644
--- a/asxv5pxx/asxxsrc/aslex.c
+++ b/asxv5pxx/asxxsrc/aslex.c
@@ -764,6 +764,9 @@ loop:	if (asmc == NULL) return(0);
 		break;
 	}
 	chopcrlf(ib);
+	/* For GCC, strip out lines beginning with the hash sign */
+	if (ib[0] == '#')
+		goto loop;
 	strcpy(ic, ib);
 	scanline();
 	return(1);
diff --git a/asxv5pxx/asxxsrc/aslist.c b/asxv5pxx/asxxsrc/aslist.c
index 041c2ee..291a88d 100644
--- a/asxv5pxx/asxxsrc/aslist.c
+++ b/asxv5pxx/asxxsrc/aslist.c
@@ -504,7 +504,7 @@ list()
 				 */
 				nl = (!cflag && !(opcycles & OPCY_NONE) && (listing & LIST_CYC)) ? (n-1) : n;
 				nl = (nb > nl) ? nl : nb;
-	 			list1(wp, wpt, nl);
+				list1(wp, wpt, nl);
 				wp += nl;
 				wpt += nl;
 				op += (nl * b);
@@ -966,7 +966,7 @@ int hlr_nb;
  *	local variables:
  *		char *	frmt		string format
  *		char	np[]		new page string
- *		char	tp[]		temporary string	
+ *		char	tp[]		temporary string
  *
  *	global variables:
  *		char	cpu[]		cpu type string
@@ -998,12 +998,12 @@ int flag;
 		if (flag) {
 			/*
 			 *12345678901234567890123456789012345678901234567890123456789012345678901234567890
-			 *ASxxxx Assembler Vxx.xx  (Motorola 6809)                                Page 1
+			 *ASxxxx Assembler Vxx.xx (Motorola 6809)                                 Page 1
 			 */
-		 	/*
+			/*
 			 * Total string length is 78 characters.
 			 */
-			sprintf(tp, "ASxxxx Assembler %s  (%s)", VERSION, cpu);
+			sprintf(tp, "ASxxxx Assembler %s (%s)", VERSION, cpu);
 			sprintf(np, "%-78s", tp);
 			/*
 			 * Right justify page number in string.
@@ -1013,12 +1013,16 @@ int flag;
 			/*
 			 * Output string.
 			 */
+#if NOFORMFEED
+			fprintf(fp, "%s\n", np);
+#else
 			fprintf(fp, "\f%s\n", np);
+#endif
 			/*
 			 *12345678901234567890123456789012345678901234567890123456789012345678901234567890
 			 *Hexadecimal [16-Bits]                                 Sun Sep 15 17:22:25 2013
 			 */
-		 	/*
+			/*
 			 * Total string length is 78 characters.
 			 */
 			switch(xflag) {
@@ -1231,7 +1235,7 @@ FILE *fp;
 				break;
 
 			}
-			fprintf(fp, "%s", frmt);
+			fputs(frmt, fp);
 		} else {
 			sa = sp->s_addr & a_mask;
 #ifdef	LONGINT
diff --git a/asxv5pxx/asxxsrc/asmain.c b/asxv5pxx/asxxsrc/asmain.c
index 708b9a7..b88ce92 100644
--- a/asxv5pxx/asxxsrc/asmain.c
+++ b/asxv5pxx/asxxsrc/asmain.c
@@ -112,7 +112,7 @@
  *					address of symbols caused by
  *					variable length instruction formats
  *		int	gflag		-g, make undefined symbols global flag
- *		int	tflag		-h, hidden option for diagnostic info dump
+ *		int	tflag		-t, hidden option for diagnostic info dump
  *		char	ib[]		assembler-source text line
  *		int	ifcnd[]		array of IF statement condition
  *					values (0 = FALSE) indexed by tlevel
@@ -198,7 +198,6 @@ char *argv[];
 		exit(ER_FATAL);
 	}
 
-	fprintf(stdout, "\n");
 	q = NULL;
 	asmc = NULL;
 	asmp = NULL;
@@ -2562,11 +2561,11 @@ VOID
 usage(n)
 int n;
 {
-	char   **dp;
+	char **dp;
 
-	fprintf(stderr, "\nASxxxx Assembler %s  (%s)", VERSION, cpu);
-	fprintf(stderr, "\nCopyright (C) %s  Alan R. Baldwin", COPYRIGHT);
-	fprintf(stderr, "\nThis program comes with ABSOLUTELY NO WARRANTY.\n\n");
+	fprintf(stderr, "ASxxxx Assembler " VERSION " (%s)\n", cpu);
+	fprintf(stderr, "Copyright (C) " COPYRIGHT " Alan R. Baldwin\n");
+	fprintf(stderr, "This program comes with ABSOLUTELY NO WARRANTY.\n\n");
 	for (dp = usetxt; *dp; dp++)
 		fprintf(stderr, "%s\n", *dp);
 	asexit(n);
diff --git a/asxv5pxx/asxxsrc/asout.c b/asxv5pxx/asxxsrc/asout.c
index b86891a..cb621ff 100644
--- a/asxv5pxx/asxxsrc/asout.c
+++ b/asxv5pxx/asxxsrc/asout.c
@@ -1025,7 +1025,7 @@ outall()
  *		char *	txtp		pointer to txt array
  *
  *	functions called:
- *		int	fprintf()	c_library
+ *		int	fputc()		c_library
  *		VOID	out()		asout.c
  *
  *	side effects:
@@ -1036,12 +1036,12 @@ VOID
 outdot()
 {
 	if (oflag && pass==2) {
-		fprintf(ofp, "T");
+		fputc('T', ofp);
 		out(txt,(int) (txtp-txt));
-		fprintf(ofp, "\n");
-		fprintf(ofp, "R");
+		fputc('\n', ofp);
+		fputc('R', ofp);
 		out(rel,(int) (relp-rel));
-		fprintf(ofp, "\n");
+		fputc('\n', ofp);
 		txtp = txt;
 		relp = rel;
 	}
@@ -1116,7 +1116,8 @@ int nr;
  *		char *	txtp		pointer to txt array
  *
  *	functions called:
- *		int	fprintf()	c_library
+ *		int	fputc()		c_library
+ *		int	fputs()		c_library
  *		VOID	out()		asout.c
  *
  *	side effects:
@@ -1129,12 +1130,12 @@ outbuf(s)
 char *s;
 {
 	if (txtp > &txt[a_bytes]) {
-		fprintf(ofp, "T");
+		fputc('T', ofp);
 		out(txt,(int) (txtp-txt));
-		fprintf(ofp, "\n");
-		fprintf(ofp, "%s", s);
+		fputc('\n', ofp);
+		fputs(s, ofp);
 		out(rel,(int) (relp-rel));
-		fprintf(ofp, "\n");
+		fputc('\n', ofp);
 	}
 	txtp = txt;
 	relp = rel;
@@ -1180,6 +1181,8 @@ char *s;
  *
  *	functions called:
  *		int	fprintf()	c_library
+ *		int	fputc()		c_library
+ *		int	fputs()		c_library
  *		VOID	outarea()	asout.c
  *		VOID	outbank()	asout.c
  *		VOID	outmode()	asout.c
@@ -1253,9 +1256,10 @@ outgsd()
 	 * Module name
 	 */
 	if (module[0]) {
-		fprintf(ofp, "M ");
+		fputs("M ", ofp);
 		ptr = &module[0];
-		fprintf(ofp, "%s\n", ptr);
+		fputs(ptr, ofp);
+		fputc('\n', ofp);
 	}
 
 	/*
@@ -1330,6 +1334,7 @@ outgsd()
  *
  *	functions called:
  *		int	fprintf()	c_library
+ *		int	fputc()		c_library
  *		void	out()		.REL file data format processor
  *
  *	side effects:
@@ -1358,7 +1363,7 @@ struct mode *mp;
 			fprintf(ofp, "G %03u %03u", index, i*16);
 		}		
 		out(p + i*16, 16);
-		fprintf(ofp, "\n");
+		fputc('\n', ofp);
 	}
 }
 
@@ -1379,6 +1384,8 @@ struct mode *mp;
  *
  *	functions called:
  *		int	fprintf()	c_library
+ *		int	fputc()		c_library
+ *		int	fputs()		c_library
  *
  *	side effects:
  *		The B line is sent to the .REL file.
@@ -1390,8 +1397,8 @@ struct bank *bp;
 {
 	char * frmt;
 
-	fprintf(ofp, "B ");
-	fprintf(ofp, "%s", &bp->b_id[0]);
+	fputs("B ", ofp);
+	fputs(&bp->b_id[0], ofp);
 
 #ifdef	LONGINT
 	switch(xflag) {
@@ -1411,10 +1418,10 @@ struct bank *bp;
 
 	fprintf(ofp, frmt, bp->b_base & a_mask, bp->b_size & a_mask, bp->b_map & a_mask, bp->b_flag);
 	if ((bp->b_fsfx != NULL) && *bp->b_fsfx) {
-		fprintf(ofp, " fsfx %s\n", bp->b_fsfx);
-	} else {
-		fprintf(ofp, "\n");
+		fputs(" fsfx ", ofp);
+		fputs(bp->b_fsfx, ofp);
 	}
+	fputc('\n', ofp);
 }
 
 /*)Function	VOID	outarea(ap)
@@ -1436,6 +1443,8 @@ struct bank *bp;
  *
  *	functions called:
  *		int	fprintf()	c_library
+ *		int	fputc()		c_library
+ *		int	fputs()		c_library
  *
  *	side effects:
  *		The A line is sent to the .REL file.
@@ -1461,8 +1470,8 @@ struct area *ap;
 	default:	a_flag |= (A_REL | A_CON);	break;
 	}
 
-	fprintf(ofp, "A ");
-	fprintf(ofp, "%s", &ap->a_id[0]);
+	fputs("A ", ofp);
+	fputs(&ap->a_id[0], ofp);
 
 #ifdef	LONGINT
 	switch(xflag) {
@@ -1493,7 +1502,7 @@ struct area *ap;
 			fprintf(ofp, " bank %u", bp->b_ref);
 		}
 	}
-	fprintf(ofp, "\n");
+	fputc('\n', ofp);
 }
 
 /*)Function	VOID	outsym(sp)
@@ -1515,6 +1524,7 @@ struct area *ap;
  *
  *	functions called:
  *		int	fprintf()	c_library
+ *		int	fputs()		c_library
  *
  *	side effects:
  *		The S line is sent to the .REL file.
@@ -1532,9 +1542,9 @@ struct sym *sp;
 	 */
 	s_addr = sp->s_addr & a_mask;
 
-	fprintf(ofp, "S ");
-	fprintf(ofp, "%s", &sp->s_id[0]);
-	fprintf(ofp, " %s", sp->s_type==S_NEW ? "Ref" : "Def");
+	fputs("S ", ofp);
+	fputs(&sp->s_id[0], ofp);
+	fputs(sp->s_type==S_NEW ? " Ref" : " Def", ofp);
 
 #ifdef	LONGINT
 	switch(xflag) {
diff --git a/asxv5pxx/asxxsrc/asxxxx.h b/asxv5pxx/asxxsrc/asxxxx.h
index 09060c0..69c7356 100644
--- a/asxv5pxx/asxxsrc/asxxxx.h
+++ b/asxv5pxx/asxxsrc/asxxxx.h
@@ -39,7 +39,6 @@
 /*
  * System Include Files
  */
-
 #include <stdlib.h>
 #include <stdio.h>
 #include <setjmp.h>
@@ -47,22 +46,9 @@
 #include <time.h>
 
 /*
- * Local Definitions
- */
-
-#define	VERSION	"V05.11"
-#define	COPYRIGHT "2015"
-
-/*
- * To include NoICE Debugging set non-zero
+ * Include Config File
  */
-#define	NOICE	1
-
-/*
- * To include SDCC Debugging set non-zero
- */
-#define	SDCDB	1
-
+#include "../config.h"
 
 /*
  * The assembler requires certain variables to have
@@ -151,12 +137,10 @@
 #define	LFTERM	'('		/* Left expression delimeter */
 #define	RTTERM	')'		/* Right expression delimeter */
 
-#define NCPS	256		/* Characters per symbol */
 #define	HUGE	1000		/* A huge number */
-#define NERR	2		/* Errors per line */
-#define NINPUT	380		/* Input buffer size */
-#define NCODE	380		/* Listing code buffer size */
-#define NTITL	80		/* Title buffer size */
+#define	NERR	2		/* Errors per line */
+#define	NCODE	(NINPUT)	/* Listing code buffer size */
+#define	NTITL	80		/* Title buffer size */
 #define	NSBTL	80		/* SubTitle buffer size */
 #define	NHASH	(1 << 6)	/* Buckets in hash table */
 #define	HMASK	(NHASH - 1)	/* Hash mask */
@@ -165,13 +149,12 @@
 #define	MAXINC	6		/* Maximum nesting of include files */
 #define	MAXMCR	20		/* Maximum nesting of macro expansions */
 #define	MAXIF	10		/* Maximum nesting of if/else/endif */
-#define	FILSPC	80		/* Chars. in filespec */
 
-#define NLIST	0		/* No listing */
-#define SLIST	1		/* Source only */
-#define ALIST	2		/* Address only */
+#define	NLIST	0		/* No listing */
+#define	SLIST	1		/* Source only */
+#define	ALIST	2		/* Address only */
 #define	BLIST	3		/* Address only with allocation */
-#define CLIST	4		/* Code */
+#define	CLIST	4		/* Code */
 #define	ELIST	5		/* Equate or IF conditional evaluation */
 
 #define	HLR_NLST	0x0080	/* For HLR file only */
@@ -220,7 +203,7 @@
 /*
  * Default Page Length Mask
  */
-#define	DEFAULT_PMASK	0xFF	/* 256 Element Boundary / Length */ 
+#define	DEFAULT_PMASK	0xFF	/* 256 Element Boundary / Length */
 
 /*
  * NTXT must be defined to have the same value in
diff --git a/asxv5pxx/change.txt b/asxv5pxx/change.txt
index 65df7cb..ef5d306 100644
--- a/asxv5pxx/change.txt
+++ b/asxv5pxx/change.txt
@@ -3,87 +3,87 @@
 
 
            Asxxxx/ASlink version 5.10 is considered
-	   a major release version.  
+	   a major release version.
 
         Version 5.10
         2014_10_31
-        
+
            (1)  Rewrite of listing to relocated listing translation
                 code in the assembler and the linker base code.
                 The Assemblers now create a .lst to .rst hint file
                 with the extension .hlr (when both .lst and .rel
                 files are created by the assembler).
-        
+
            (2)  Add as6100 assembler (Intersil IM6100 / Harris HM6100)
-        
-           (3)  Add as78k0s assembler (Renesas/NEC 78K/0S) 
+
+           (3)  Add as78k0s assembler (Renesas/NEC 78K/0S)
 
 
            Summary  of  changes/additions  to the ASxxxx Assemblers from
-        Version 4.11 to Version 5.06.  
+        Version 4.11 to Version 5.06.
 
         Version 5.00 Update 6
-        
+
            This  update  for  Version  5.00  of the  ASxxxx Cross
         Assemblers rolls up updates 1, 2, 3, 4, and 5 with fixes
         for the following:
-        
+
            (1)  Fix asscmp assembler (pre-increment on fetch).
-        
+
            (2)  Fix aslink error reporting for PC relative modes.
 
         Version 5.00 Update 5
         2012_08_01
-        
+
         Update_05 for the ASxxxx Assembler and Linker Version 5.00
         (use 'pkunzip -d u05500.zip' for extraction with MS-DOS)
         (use 'unzip -L -a u05500.zip' for extraction with Linux)
-        
+
                See the note about merging
                this update with the
                asxv5pxx distribution.
-        
+
            This  update  for  Version  5.00  of the  ASxxxx Cross
         Assemblers rolls up updates 1, 2, 3, and 4 with the addition of
         a new assembler and fixes:
-        
+
            (1)  A new cross assembler for the Fairchild
                 F8 microprocessor (or Mostek 3870).
-        
+
            (2)  Minor syntactical changes for ANSI C compatability,
                 fix type conversion warnings, and update the
                 various build, make, and test files.
-        
-        
+
+
            Update 4 Items
-        
+
            (1)  The AS8048 base opcode value for the JMPP
                 instruction should be B3 and NOT 83.
-        
+
            (2)  The AS8051 assembler calculates incorrect
                 offsets when using the program counter, ".",
                 as a destination in the instructions having
                 a PC-Relative addressing mode.  These
                 instructions include: jbc, jb, jbn, jc,
                 jnc, jz, jnz, cjne, and djnz.
-        
-        
+
+
            Update 3 Items
-        
+
            (1)  A new cross assembler for the Fairchild
                 F8 microprocessor (or Mostek 3870).
-        
+
            (2)  Minor syntactical changes for ANSI C compatability,
                 fix type conversion warnings, and update the
                 various build, make, and test files.
-        
+
            (1)  New cross assemblers for STMicroelectronics
                 ST6, ST7, and STM8 microprocessors.
-        
+
            (2)  An ASlink list file update error fix (-u option)
                 causing some errors not to be inserted into the
                 created .rst file.
-        
+
            (3)  An additional ASxxxx assembler option (-v) which
                 enables checking for out of range signed / unsigned
                 values in symbol equates and arithmetic operations.
@@ -91,59 +91,59 @@
                 assemblers use unsigned arithmetic for calculations.
                 (e.g. for a 2-byte machine -32768 and 32768 are both
                 represented as 0x8000)
-        
-        
+
+
            Update 2 Items
-        
+
            (1)  When using the assembler directive .end to specify
                 the code entry address the assembler fails to set
                 the variable .__.END. as a global.  Therefor the
                 value of .__.END. is not passed to the linker and
                 the start address frame is always zero.
-        
+
            (2)  The linker will fail to create a start address frame
                 when there is no code generated within the area/bank
                 referenced by the .__.END. variable.
-        
-        
+
+
            Update 1 Items
-        
+
            (1)  The newest versions of gcc (and perhaps other
                 compilers) give warnings about missing arguments
                 in the fprintf() function.  This update replaces
                 fprintf(arg1, arg2) with fprintf(arg1, "%s", arg2)
                 in each affected line of code.
-        
+
            (2)  The newest versions of gcc (and perhaps other
                 compilers) have defined 'getline' as a standard
                 function in 'stdio.h'.  This conflicts with the
                 function 'getline()' in the ASxxxx package.
                 All references to 'getline()' have been changed
                 to 'nxtline()'.
-        
-        
+
+
            Before merging the asxv5pxx directory and subdirectories with
         the V5.00 distribution the following files/directories must be
         deleted:
-        
+
                 [asxv5pxx\asf2mc8\f8mch.c
                 [asxv5pxx\asf2mc8\f8adr.c
                 [asxv5pxx\asf2mc8\f8pst.c
                 [asxv5pxx\asf2mc8\f8.h
-        
+
                 [asxv5pxx\asxmak\vc6\asf2mc8]
                 [asxv5pxx\asxmak\vs05\asf2mc8]
-        
-        
+
+
 
         2011_07_24 Version 5.00 Update 4
-        
+
            This  update  for  Version  5.00  of the  ASxxxx Cross
         Assemblers includes fixes for the following errors:
-        
+
            (1)  The AS8048 base opcode value for the
                 JMPP instruction should be B3 and NOT 83.
-        
+
            (2)  The AS8051 assembler calculates incorrect
                 offsets when using the program counter, ".",
                 as a destination in the instructions having
@@ -154,18 +154,18 @@
 
 
         2010_10_31 Version 5.00 Update 3
-        
+
            This  update  for  Version  5.00  of the  ASxxxx Cross
         Assemblers rolls up updates 1 and 2 with the addition of
         three new assemblers and fixes:
-        
+
            (1)  New cross assemblers for STMicroelectronics
                 ST6, ST7, and STM8 microprocessors.
-        
+
            (2)  An ASlink list file update error fix (-u option)
                 causing some errors not to be inserted into the
                 created .rst file.
-        
+
            (3)  An additional ASxxxx assembler option (-v) which
                 enables checking for out of range signed / unsigned
                 values in symbol equates and arithmetic operations.
@@ -173,29 +173,29 @@
                 assemblers use unsigned arithmetic for calculations.
                 (e.g. for a 2-byte machine -32768 and 32768 are both
                 represented as 0x8000)
-        
-        
+
+
            Update 2 Items
-        
+
            (1)  When using the assembler directive .end to specify
                 the code entry address the assembler fails to set
                 the variable .__.END. as a global.  Therefor the
                 value of .__.END. is not passed to the linker and
                 the start address frame is always zero.
-        
+
            (2)  The linker will fail to create a start address frame
                 when there is no code generated within the area/bank
                 referenced by the .__.END. variable.
-        
-        
+
+
            Update 1 Items
-        
+
            (1)  The newest versions of gcc (and perhaps other
                 compilers) give warnings about missing arguments
                 in the fprintf() function.  This update replaces
                 fprintf(arg1, arg2) with fprintf(arg1, "%s", arg2)
                 in each affected line of code.
-        
+
            (2)  The newest versions of gcc (and perhaps other
                 compilers) have defined 'getline' as a standard
                 function in 'stdio.h'.  This conflicts with the
@@ -206,16 +206,16 @@
 
 
         2010_04_01 Version 5.00 Update 2
-        
+
            This  update  for  Version  5.00  of the  ASxxxx Cross
         Assemblers includes fixes for the following errors:
-        
+
            (1)  When using the assembler directive .end to specify
                 the code entry address the assembler fails to set
                 the variable .__.END. as a global.  Therefor the
                 value of .__.END. is not passed to the linker and
                 the start address frame is always zero.
-        
+
            (2)  The linker will fail to create a start address frame
                 when there is no code generated within the area/bank
                 referenced by the .__.END. variable.
@@ -223,17 +223,17 @@
 
 
         2010_03_03 Version 5.00 Update 1
-        
+
            This  update  for  Version  5.00  of the  ASxxxx Cross
         Assemblers includes fixes for the following errors:
-        
+
            (1)  The newest versions of gcc (and perhaps other
                 compilers) give warnings about missing arguments
                 in the fprintf() function.  This update replaces
                 fprintf(arg1, arg2) with fprintf(arg1, "%s", arg2)
                 in each affected line of code.
-        
-        
+
+
            (2)  The newest versions of gcc (and perhaps other
                 compilers) have defined 'getline' as a standard
                 function in 'stdio.h'.  This conflicts with the
@@ -247,38 +247,38 @@
 
 
            Added  a general purpose macro processor to the ASxxxx assem-
-        blers.  
+        blers.
 
            Added  true (t), false (f), and true or false (tf) condition-
         als to the  .if / .else / .endif  construct.   The  conditionals
         .ift,  .iff,  and .iftf allow replacement of the .else directive
-        making the .if / .endif construct more readable.  
+        making the .if / .endif construct more readable.
 
         e.g.    .ift    if condition is true
 
 
            An  alternate  .if  construction has been added to the ASxxxx
-        assemblers:  
+        assemblers:
 
         e.g.    .if    eq,...   if argument == 0
 
 
            The  immediate  conditional statements have been added to the
         ASxxxx  assemblers.   These   conditionals   can   replace   the
-        .if / ... / .endif construct for a single assembler source line: 
+        .if / ... / .endif construct for a single assembler source line:
 
         e.g.    .iifeq  arg     label:  .word   0x1234
 
 
            The alternate immediate conditional statements have also been
-        added to the ASxxxx assemblers:  
+        added to the ASxxxx assemblers:
 
         e.g.    .iif    eq,arg  label:  .word   0x1234
 
 
            The  listing  options  for the ASxxxx assemblers has been up-
         dated to enable/disable any of the following parameters from be-
-        ing output to a generated listing file:  
+        ing output to a generated listing file:
 
             err         error codes
             loc         code location
@@ -292,28 +292,28 @@
             md          macro definition
             me          macro expansion
             meb         macro expansion binary code
-        
+
             !           sets the listing mode to
                         !(.list) or !(.nlist) before
                         applying the sublist options
-        
+
         e.g.    .nlist  (lst,pag)       ; disable .list/.nlist listing
                                         ; and pagination
 
 
            The  NOT parameter, !, is used to set the listing mode to the
-        opposite sense of the .list or .nlist directive.  For example:  
+        opposite sense of the .list or .nlist directive.  For example:
 
             .nlist (!)  is equivalent to .list and
             .list  (!)  is equivalent to .nlist
 
         To enable listing and simultaneously disable the cycle count use
-        the directive:  
+        the directive:
 
             .nlist  (!,cyc)
 
         or  if  you  wish  to suppress the listing of the .list / .nlist
-        directives:  
+        directives:
 
             .nlist              ; disables all listing
             .nlist  (!,lst)     ; enables  all listing except
@@ -323,7 +323,7 @@
            Normally  the  .list  and .nlist directives are not evaluated
         when encountered within a FALSE conditional block.  This default
         behavior  can  be  modified by specifying a non zero argument in
-        the .list or .nlist directive:  
+        the .list or .nlist directive:
 
             .nlist   1,(!,lst)  ; enables listing even within
                                 ; a FALSE conditional block
@@ -332,12 +332,12 @@
 
            The .bndry assembler directive has been added to ASxxxx.  The
         .bndry directive changes the  current  location  address  to  be
-        evenly divisible by a specified integer value.  
+        evenly divisible by a specified integer value.
 
         e.g.    .org    0
                 .bndry  4
                 ; . == 0
-        
+
                 .org    1
                 .bndry  4
                 ; . == 4
@@ -347,141 +347,141 @@
         2009_02
            Added the Cypress PSoc (M8C) ASM8C assembler
            to ASxxxx.
-        
-        
+
+
         2008_09
            Added the 8048 (8021, 8022, and 8041) AS8048
            assembler to Asxxxx.
-        
-        
+
+
         2008_02
            Added the SC/MP ASSCMP assembler to ASxxxx.
 
 
         2008_02_03 (Version 4.11 Update 4)
-        
+
            An update to the AS2650 assembler to
            fix the following errors:
-        
+
            1)  The indexed addressing mode generates invalid
                code by using the first argument register as
                the index register: (addr = 0x1234)
-        
+
                    loda    r0,[addr,r1]          0C F2 34
                            this should give      0D F2 34
-        
+
            2)  The index addressing mode did not generate
                an addressing error when the first argument
                register was not r0:
-        
+
                    stra    r1,[addr,r2]  should give an 'a'
                            error, the source must be r0
-        
-        
+
+
                    loda    r2,[addr,r3]  should give an 'a'
                            error, the destination must be r0
-        
-           3)  The S2650 auto increment and decrement indexing 
+
+           3)  The S2650 auto increment and decrement indexing
                modes always perform the register update before
                the register is used. i.e. +Rn or -Rn.  The
                assembler now accepts +Rn or Rn+ as meaning
                pre-increment and -Rn or Rn- as meaning
                pre-decrement.
-        
-        
+
+
            The AS2650 assembler tstscn files have been updated
            for testing the assemblers.
-        
-        
-        
+
+
+
         2007_10_21 (Version 4.11 Fix)
-        
+
            In the AS6816 assembler the instruction ANDP gives
            wrong object code. Changed from 37 2A  to  37 3A.
 
 
         2007_04_01 (Version 4.11 Update 3)
-        
+
            An update to the ASPIC assembler and
            associated fix to ASLINK:
-        
+
            1)  Change the pic addressing to lo/hi from hi/lo
                byte ordering.
-        
+
            2)  The update fixes an error in the pic17 series
                LCALL instruction.
-        
+
            3)  A rewrite of the pic18 series assembler to change
                the PC addressing from 1 per 16-bit word to 1 per
                8-bit byte and add the extended instruction set.
-        
+
            4)  Modify the Linker Merge Mode processing to take into
                account the discarded low order bits for PC Relative
                Addressing.
-        
+
            5)  New  tstscn files for testing the assemblers.
-        
-        
+
+
         2006_11_01 (Version 4.11 Optional Update 2)
-        
+
            1)  OS9  definition files and an  OS9 assembler module
                which creates the OS9 header, code and data areas,
                and the module CRC block:
-        
+
                     os9_mod.def       OS9 Module Definitions
                     os9_sys.def       OS9 Sytem  Definitions
                     os9_mod.asm       OS9 Module Begin / End Code
-        
+
            2)  a program, s19os9, to post-process  assembled  OS9
                modules in  S19  format into  binary  OS9  modules
                with the appropriate  header  checksum  and module
                CRC values calculated.
-        
+
            3)  new  make  and  project files which may be used to
                compile the s19os9 program.
 
 
         2006_11_01 (Version 4.11 Optional Update 01)
-        
+
            The .list  and  .nlist  directives  are  now  modified
            by .if / .else / .endif  processing  so  that they are
            active only in a TRUE clause.
-        
+
            The  .page  and  .include  directives are now modified
            by the .list and .nlist  directives so that pagination
            occurs only when listing is active.
-        
+
            The new  default functionality for the  .list,  .nlist
            and .page directives may  be  modified by including an
            optional argument  in the  directive as shown here for
            the the .list directive:
-        
+
               .list    arg
-        
+
            a non-zero argument invokes the directive irrespective
            of the .if / .else / .endif status.
-        
-        
+
+
         2006_07_26 (Version 4.11 Patch 01)
-        
+
            The  assembly  of  a  direct  page  instruction with a
            numeric  constant  causes a program  crash when a .rel
            file is created. e.g.:
-        
+
                 andb    *0x02
-        
-        
+
+
            The  use  of  a  symbolic  constant  or  symbol plus a
            a constant compiles normally.
-        
+
                 val = 0x02
-        
+
                 andb    *val
                 andb    *extern+0x01
-        
-        
+
+
            The assemblers effected are:
-        
+
                 as6809
                 as6812
                 ash8
@@ -489,29 +489,29 @@
 
 
            Summary  of  changes/additions  to the ASxxxx Assemblers from
-        Version 4.10 to Version 4.11.  
+        Version 4.10 to Version 4.11.
 
              1.  Incorporated  the patches contained in p01410.zip which
                  corrected a coding error that affected BANKS containing
-                 multiple ABS areas or mixed AREA types.  
+                 multiple ABS areas or mixed AREA types.
 
              2.  Incorporated  the patches contained in p02410.zip which
                  corrected improper use of  R_USGN  in  most  addressing
                  modes  in AS6500.  This caused unexpected 'a' errors in
                  V4.xx because of the ASxxxx core change to  32-bit  in-
-                 tegers and arithmetic.  
+                 tegers and arithmetic.
 
              3.  Incorporated  the patches contained in p03410.zip which
                  corrected errors in the  .local  and  .globl  assembler
                  directive  processing  routine that introduced unwanted
                  side effects for variable and symbol definition  files.
                  These  effects included improper definitions and incor-
-                 rect error warnings.  
+                 rect error warnings.
 
              4.  The  following  new subdirectories and their files have
-                 been added to the asxtst directory:  
+                 been added to the asxtst directory:
 
-                  *  areabank     Area and Bank Processing Test 
+                  *  areabank     Area and Bank Processing Test
                      This  directory  contains  several  test  programs:
                      ts.asm (single file - multiple areas), tm1.asm  and
                      tm2.asm  (multiple  file  -  multiple  areas),  and
@@ -522,86 +522,86 @@
                      ple linked files having no  banking,  and  multiple
                      linked  files  with banking.  These reference files
                      show in detail how the .area and  .bank  directives
-                     work together.  
+                     work together.
 
-                  *  equtst       Equate Processing Test 
+                  *  equtst       Equate Processing Test
                      This  directory  contains a test file for verifying
                      the operation of the .globl, .local, .equ, .gblequ,
                      and  .lclequ  directives  and  the  =,  ==,  and =:
-                     equalities.  
+                     equalities.
 
-                  *  inctst       Nested Include File Test 
+                  *  inctst       Nested Include File Test
 
-                  *  itst         Include File Error Reporting Test 
+                  *  itst         Include File Error Reporting Test
 
 
              5.  Incorporated  the updates contained in u01410.zip which
                  added 10 undocumented 8085 instructions to  the  AS8085
-                 assembler.  
+                 assembler.
 
 
 
            Summary  of  changes/additions  to the ASxxxx Assemblers from
-        Version 4.00 to Version 4.10.  
+        Version 4.00 to Version 4.10.
 
              1.  Added new assemblers for the Zilog EZ80, Zilog Z8, Sig-
-                 netics 2650, and Fujitsu F2MC8(L,FX) processors.  
+                 netics 2650, and Fujitsu F2MC8(L,FX) processors.
 
              2.  Added the processor cycle count option (-c) to all pro-
-                 cessors.  
+                 cessors.
 
              3.  Several   of  the  assemblers  (ASZ80,  ASRAB,  AS6805,
                  AS6808, AS6812, ASF2MC8, ...) now  support  subsets  or
                  supersets  of  their basic opcodes by the use of assem-
-                 bler specific directives.  
+                 bler specific directives.
 
              4.  Added .ifeq, .ifne, .iflt, .ifgt, .ifle, and .ifge con-
-                 ditional assembly directives.  
+                 ditional assembly directives.
 
              5.  Added  support  for the Tandy Color Computer Disc Basic
-                 binary file format to ASLINK.  
+                 binary file format to ASLINK.
 
-             6.  Problem:  
+             6.  Problem:
                  When  an area size is equal to the 'address space size'
                  the size parameter is reported as 0.  (A normal  condi-
                  tion  caused  by  address rollover to 0.) Aslink inter-
-                 preted this as a 0 size.  
+                 preted this as a 0 size.
 
-                 Fix:  
+                 Fix:
                  A  new area 'Output Code Flag' bit was defined to indi-
                  cate when data is  defined  in  an  area.   ASxxxx  and
                  Aslink  have  been updated to set and process this area
-                 flag bit.  
+                 flag bit.
 
-             7.  Problem:  
+             7.  Problem:
                  The  use  of  the .end assembler directive in an Asxxxx
                  assembler would cause Aslink  to  output  the  optional
-                 start address in all output files.  
+                 start address in all output files.
 
-                 Fix:  
+                 Fix:
                  Updated  Aslink  to  output  the optional start address
                  only in the output file associated with  the  area/bank
-                 containing the .end directive.  
+                 containing the .end directive.
 
-             8.  Problem:  
+             8.  Problem:
                  Aslink  creates  output  files for banks with no output
-                 data.  
+                 data.
 
-                 Fix:  
+                 Fix:
                  Aslink  now  deletes  any created output file for banks
-                 with no data.  
+                 with no data.
 
              9.  Incorporated  the  patches  contained in p01400.zip for
                  files t1802.asm and 1802pst.c to correct for  an  error
                  in  the  opcodes  generated  for  the  BM,  BL, and BNF
-                 mnemonics.  
+                 mnemonics.
 
             10.  Incorporated  the  patches  contained in p02400.zip for
                  file ds8adr.c to correct for an  error  in  the  direct
-                 page addressing mode of AS8xCxxx.  
+                 page addressing mode of AS8xCxxx.
 
             11.  Incorporated  the  patches  contained in p03400.zip for
                  file rabmch.c to correct for an error in the processing
-                 of the "ret cc" instruction.  
+                 of the "ret cc" instruction.
 
-            12.  Made many corrections to internal code comments.  
+            12.  Made many corrections to internal code comments.
diff --git a/asxv5pxx/config.h b/asxv5pxx/config.h
new file mode 100644
index 0000000..44e3b81
--- /dev/null
+++ b/asxv5pxx/config.h
@@ -0,0 +1,19 @@
+#define VERSION     "V05.11 (GCC6809)" /* Version number */
+#define COPYRIGHT   "2015"             /* Copyright year */
+#define NCPS        512                /* Characters per symbol */
+#define NINPUT      (NCPS*2)           /* Input buffer size */
+#define FILSPC      (NINPUT+10)        /* File spec length */
+#define MAXHASHBIT  16                 /* Maximum bits for a hash table */
+#define NOFORMFEED  1                  /* Disable form feed in listing */
+#define M6809STRICT 1                  /* No opcode compatibility */
+
+/*
+ * To include NoICE Debugging set non-zero
+ */
+#define NOICE      1
+
+/*
+ * To include SDCC Debugging set non-zero
+ */
+#define SDCDB      1
+
diff --git a/asxv5pxx/home.htm b/asxv5pxx/home.htm
new file mode 100644
index 0000000..2a79531
--- /dev/null
+++ b/asxv5pxx/home.htm
@@ -0,0 +1,8 @@
+<!DOCTYPE HTML>
+<html>
+	<head>
+		<meta http-equiv="refresh" content="0; url=asxhtml/asxdoc.htm" />
+	</head>
+	<body bgcolor="#C0C0C0">
+	</body>
+</html>
diff --git a/asxv5pxx/libsrc/ardata.c b/asxv5pxx/libsrc/ardata.c
new file mode 100644
index 0000000..16a0672
--- /dev/null
+++ b/asxv5pxx/libsrc/ardata.c
@@ -0,0 +1,55 @@
+/* ardata.c */
+
+/*
+ * (C) Copyright 1989,1990
+ * All Rights Reserved
+ *
+ * Alan R. Baldwin
+ * 721 Berkeley St.
+ * Kent, Ohio  44240
+ */
+
+#include "aslib.h"
+
+struct lfile *filep, *cfp;
+char ib[NINPUT], *ip;
+
+char ctype[128] = {
+/*NUL*/	ILL,	ILL,	ILL,	ILL,	ILL,	ILL,	ILL,	ILL,
+/*BS*/	ILL,	SPACE,	ILL,	ILL,	SPACE,	ILL,	ILL,	ILL,
+/*DLE*/	ILL,	ILL,	ILL,	ILL,	ILL,	ILL,	ILL,	ILL,
+/*CAN*/	ILL,	ILL,	ILL,	ILL,	ILL,	ILL,	ILL,	ILL,
+/*SPC*/	SPACE,	ETC,	ETC,	ETC,	LETTER,	BINOP,	BINOP,	ETC,
+/*(*/	ETC,	ETC,	BINOP,	BINOP,	ETC,	BINOP,	LETTER,	BINOP,
+/*0*/	DGT2,	DGT2,	DGT8,	DGT8,	DGT8,	DGT8,	DGT8,	DGT8,
+/*8*/	DGT10,	DGT10,	ETC,	ETC,	BINOP,	ETC,	BINOP,	ETC,
+/*@*/	ETC,	LTR16,	LTR16,	LTR16,	LTR16,	LTR16,	LTR16,	LETTER,
+/*H*/	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
+/*P*/	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
+/*X*/	LETTER,	LETTER,	LETTER,	ETC,	ETC,	ETC,	BINOP,	LETTER,
+/*`*/	ETC,	LTR16,	LTR16,	LTR16,	LTR16,	LTR16,	LTR16,	LETTER,
+/*h*/	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
+/*p*/	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
+/*x*/	LETTER,	LETTER,	LETTER,	ETC,	BINOP,	ETC,	ETC,	ETC
+};
+
+#ifndef	CASE_SENSITIVE
+char ccase[128] = {
+/*NUL*/	'\000',	'\001',	'\002',	'\003',	'\004',	'\005',	'\006',	'\007',
+/*BS*/	'\010',	'\011',	'\012',	'\013',	'\014',	'\015',	'\016',	'\017',
+/*DLE*/	'\020',	'\021',	'\022',	'\023',	'\024',	'\025',	'\026',	'\027',
+/*CAN*/	'\030',	'\031',	'\032',	'\033',	'\034',	'\035',	'\036',	'\037',
+/*SPC*/	'\040',	'\041',	'\042',	'\043',	'\044',	'\045',	'\046',	'\047',
+/*(*/	'\050',	'\051',	'\052',	'\053',	'\054',	'\055',	'\056',	'\057',
+/*0*/	'\060',	'\061',	'\062',	'\063',	'\064',	'\065',	'\066',	'\067',
+/*8*/	'\070',	'\071',	'\072',	'\073',	'\074',	'\075',	'\076',	'\077',
+/*@*/	'\100',	'\141',	'\142',	'\143',	'\144',	'\145',	'\146',	'\147',
+/*H*/	'\150',	'\151',	'\152',	'\153',	'\154',	'\155',	'\156',	'\157',
+/*P*/	'\160',	'\161',	'\162',	'\163',	'\164',	'\165',	'\166',	'\167',
+/*X*/	'\170',	'\171',	'\172',	'\133',	'\134',	'\135',	'\136',	'\137',
+/*`*/	'\140',	'\141',	'\142',	'\143',	'\144',	'\145',	'\146',	'\147',
+/*h*/	'\150',	'\151',	'\152',	'\153',	'\154',	'\155',	'\156',	'\157',
+/*p*/	'\160',	'\161',	'\162',	'\163',	'\164',	'\165',	'\166',	'\167',
+/*x*/	'\170',	'\171',	'\172',	'\173',	'\174',	'\175',	'\176',	'\177'
+};
+#endif
diff --git a/asxv5pxx/libsrc/armain.c b/asxv5pxx/libsrc/armain.c
new file mode 100644
index 0000000..e6b015e
--- /dev/null
+++ b/asxv5pxx/libsrc/armain.c
@@ -0,0 +1,493 @@
+/* armain.c */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "aslib.h"
+#define ZLIBARCH_STATIC
+#include "zlibarch.h"
+
+static char tag_libbeg[6] = "LIB";
+static char tag_libend[6] = "END";
+static char tag_objbeg[6] = "L0";
+static char tag_objend[6] = "L1";
+static int tag_libsz = sizeof("LIB")-1;
+static int tag_objsz = sizeof("L0")-1;
+
+static int creation_flag = 0;
+static int verbose_level = 0;
+static int verbose_action = 0;
+#define VERBOSE_LEVEL
+#include "common.c"
+
+
+
+/* basenam:
+ *  Strips path from the filename.
+ */
+static char *basenam(char *filename)
+{
+	char *p;
+
+	p = strrchr(filename, '/');
+	if (p != NULL)
+		return p+1;
+
+	return filename;
+}
+
+
+
+/* copycontents:
+ *  Copy the contents from src to dst.
+ */
+static void copycontents(char *buffer, int buflen, FILE *src, FILE *dst)
+{
+	while (fgets(buffer, buflen, src)) {
+		striplineend(buffer);
+		FPUTS(buffer, dst);
+		FPUTS("\n", dst);
+	}
+}
+
+
+
+/* create_archive:
+ *  Creates an empty archive.
+ */
+static void create_archive(char *filename)
+{
+	FILE *libf;
+	char *name;
+
+	libf = fopen(filename, "w");
+	if (!libf) {
+		fprintf(stderr, "Error: cannot create '%s'.\n", filename);
+		exit(1);
+	}
+
+	if (!creation_flag)
+		fprintf(stderr, "Warning: '%s' did not exist.\n", filename);
+
+	name = basenam(filename);
+	fprintf(libf, "%s %s\n", tag_libbeg, name);
+	fprintf(libf, "%s %s\n", tag_libend, name);
+	fclose(libf);
+}
+
+
+
+/* name_in_list:
+ *  Helper for finding whether a name is present in the list.
+ */
+static int name_in_list(char *name, struct lfile *list)
+{
+	while (list) {
+		if (!strcmp(name, list->f_idp)) {
+			list->f_found = 1;
+			return 1;
+		}
+		list = list->f_flp;
+	}
+
+	return 0;
+}
+
+
+
+/* append:
+ *  Appends members to an archive.
+ */
+static void append(char *arname, struct lfile *memberp)
+{
+	FILE *libf, *libftmp;
+	char modname[NCPS];
+	char line[FILSPC];
+	char tmpfile[FILSPC];
+	int ret;
+	long offset;
+
+	verbose_action = 'a';
+
+	libf = FOPEN(arname, "r");
+	if (!libf) {
+		create_archive(arname);
+		libf = FOPEN(arname, "r");
+	}
+	if (!libf) {
+		fprintf(stderr, "Error: cannot open '%s'.\n", arname);
+		exit(1);
+	}
+	ret = snprintf(tmpfile, FILSPC, "%s.tmp", arname);
+	if (ret <= 0 || ret >= FILSPC-1)
+		*tmpfile = 0;
+#ifdef ZLIBARCH
+	libftmp = FOPEN(tmpfile, FDIRECT(libf) ?  "wT" : "w");
+#else
+	libftmp = FOPEN(tmpfile, "w");
+#endif
+	if (!libftmp) {
+		fprintf(stderr, "Error: cannot create temporary file.\n");
+		exit(1);
+	}
+
+	skipheader(libf);
+
+	/* seek 'END' marker */
+	for (offset=0; FGETS(line, FILSPC, libf) != NULL && strncmp(line, tag_libend, tag_libsz); offset=FTELL(libf)) {
+		striplineend(line);
+		FPUTS(line, libftmp);
+		FPUTS("\n", libftmp);
+	}
+	if (FERROR(libf) || FEOF(libf) || FSEEK(libf, offset, SEEK_SET) < 0) {
+		fprintf(stderr, "Error: cannot seek 'END' marker.\n");
+		FCLOSE(libftmp);
+		remove(tmpfile);
+		exit(1);
+	}
+
+	FCLOSE(libf);
+
+	*modname = 0;
+	filep = memberp;
+	cfp = NULL;
+
+	while ((ret = nxtline())) {
+		if (ret == 2) {
+			if (*modname)
+				FPRINTF(libftmp, "%s %s\n", tag_objend, modname);
+
+			strcpy(modname, basenam(cfp->f_idp));
+			FPRINTF(libftmp, "%s %s\n", tag_objbeg, modname);
+		}
+
+		FPUTS(ib, libftmp);
+		FPUTS("\n", libftmp);
+	}
+
+	FPRINTF(libftmp, "%s %s\n", tag_objend, modname);
+	FPRINTF(libftmp, "%s %s\n", tag_libend, basenam(arname));
+	FCLOSE(libftmp);
+
+	/* replace existing archive by new one */
+	remove(arname);
+	rename(tmpfile, arname);
+}
+
+
+
+/* replace:
+ *  Adds members to an archive with replacement or deletes them.
+ */
+static void replace(char *arname, struct lfile *memberp, int delete)
+{
+	FILE * libf, *newf = NULL;
+	char modname[NCPS];
+	char newb[NINPUT];
+	int replaced, ret;
+	char tmpfile[FILSPC];
+#ifdef ZLIBARCH
+	int direct = 1;
+#endif
+
+	verbose_action = 0;
+
+	/* check that the archive exists */
+	if ((libf = FOPEN(arname, "r"))) {
+#ifdef ZLIBARCH
+		direct = FDIRECT(libf);
+#endif
+		FCLOSE(libf);
+		libf = NULL;
+	}
+	else {
+		if (delete) {
+			fprintf(stderr, "Error: cannot open '%s'.\n", arname);
+			exit(1);
+		}
+		create_archive(arname);
+	}
+
+	filep = new_lfile(arname, 1);
+	cfp = NULL;
+
+	while (memberp) {
+		if (!delete) {
+			if (verbose_level)
+				fprintf(stdout, "r - %s\n", memberp->f_idp);
+			newf = fopen(memberp->f_idp, "r");
+			if (!newf) {
+				fprintf(stderr, "Error: cannot open '%s'.\n", memberp->f_idp);
+				if (libf) {
+					FCLOSE(libf);
+					remove(tmpfile);
+				}
+				exit(1);
+			}
+		}
+		else {
+			if (verbose_level)
+				fprintf(stdout, "d - %s\n", memberp->f_idp);
+		}
+
+		ret = snprintf(tmpfile, FILSPC, "%s.tmp", arname);
+		if (ret <= 0 || ret >= FILSPC-1)
+			*tmpfile = 0;
+#ifdef ZLIBARCH
+		libf = FOPEN(tmpfile, direct ? "wT" : "w");
+#else
+		libf = FOPEN(tmpfile, "w");
+#endif
+		if (!libf) {
+			fprintf(stderr, "Error: cannot create temporary file.\n");
+			exit(1);
+		}
+
+		replaced = 0;
+		cfp = NULL;
+
+		while (nxtline()) {
+			if (!strncmp(ib, tag_objbeg, tag_objsz)) {
+				ip = ib + tag_objsz;
+				getid(modname, -1);
+
+				/* test whether the module name is the requested one */
+				if (!strcmp(modname, memberp->f_idp)) {
+					if (!delete) {
+						FPRINTF(libf, "%s\n", ib);  /* L0 .. */
+
+						/* copy the contents */
+						copycontents(newb, NINPUT, newf, libf);
+
+						replaced = 1;
+					}
+
+					while (nxtline()) {
+						if (!strncmp(ib, tag_objend, tag_objsz))
+							break;
+					}
+
+					if (!delete)
+						FPRINTF(libf, "%s\n", ib);   /* L1 .. */
+
+					continue;
+				}
+			}
+			else
+			if (!strncmp(ib, tag_libend, tag_libsz)) {
+				if (!delete && !replaced) {
+					strcpy(modname, basenam(memberp->f_idp));
+
+					FPRINTF(libf, "%s %s\n", tag_objbeg, modname);
+
+					/* copy the contents */
+					copycontents(newb, NINPUT, newf, libf);
+
+					FPRINTF(libf, "%s %s\n", tag_objend, modname);
+					FPRINTF(libf, "%s %s\n", tag_libend, basenam(arname));
+
+					continue;
+				}
+			}
+			FPUTS(ib, libf);
+			FPUTS("\n", libf);
+		}
+
+		FCLOSE(libf);
+		libf = NULL;
+		if (!delete)
+			fclose(newf);
+
+		/* replace existing archive by new one */
+		remove(arname);
+		rename(tmpfile, arname);
+
+		memberp = memberp->f_flp;
+	}
+}
+
+
+
+/* extract:
+ *  Extracts members from an archive.
+ */
+static void extract(char *arname, struct lfile *memberp, int create)
+{
+	FILE *newf;
+	char modname[NCPS];
+	struct lfile *lfp;
+	int err;
+	long begin, end;
+
+	verbose_action = 0;
+
+	filep = new_lfile(arname, 1);
+	cfp = NULL;
+
+	while (nxtline()) {
+		if (!strncmp(ib, tag_objbeg, tag_objsz)) {
+			ip = ib + tag_objsz;
+			getid(modname, -1);
+
+			if (!memberp || name_in_list(modname, memberp)) {
+				if (create == 1) {
+					/* list files */
+					begin = end = as_offset();
+					while (nxtline()) {
+						if (!strncmp(ib, tag_objend, tag_objsz))
+							break;
+						end = as_offset();
+					}
+					if (verbose_level)
+						fprintf(stdout, "% 7li %s\n", end-begin, modname);
+					else
+						fprintf(stdout, "%s\n", modname);
+				}
+				else {
+					/* extract or print files */
+					if (create) {
+						if (verbose_level)
+							fprintf(stdout, "x - %s\n", modname);
+						newf = fopen(modname, "w");
+						if (!newf) {
+							fprintf(stderr, "Error: cannot create '%s'.\n", modname);
+							exit(1);
+						}
+					}
+					else {
+						if (verbose_level)
+							fprintf(stdout, "\n<%s>\n\n", modname);
+						newf = stdout;
+					}
+
+					while (nxtline()) {
+						if (!strncmp(ib, tag_objend, tag_objsz))
+							break;
+						fprintf(newf, "%s\n", ib);
+					}
+
+					if (create)
+						fclose(newf);
+				}
+			}
+		}
+	}
+
+	err = 0;
+	for (lfp = memberp; lfp; lfp = lfp->f_flp) {
+		if (!lfp->f_found) {
+			fprintf(stderr, "Error: object not found '%s'.\n", lfp->f_idp);
+			err = 1;
+		}
+	}
+	if (err)
+		exit(1);
+}
+
+
+
+static char *usetxt[] = {
+	"Usage: [-]p[mod [count]...] archive [member...]",
+	"  where p must be one of:",
+	"    d   delete file(s)",
+	"    p   print contents of archive",
+	"    q   quick append file(s)",
+	"    r   insert file(s) with replacement",
+	"    t   list file(s)",
+	"    x   extract file(s)",
+	"  and mod must be one of:",
+	"    c   create new lib",
+	"    v   request verbose",
+   NULL
+};
+
+
+
+static void usage(void)
+{
+	char **dp;
+
+	fprintf(stderr, "ASxxxx Library Manager %s\n\n", VERSION);
+	for (dp = usetxt; *dp; dp++)
+		fprintf(stderr, "%s\n", *dp);
+
+	exit(1);
+}
+
+
+
+int main(int argc, char *argv[])
+{
+	char *p, *arname = NULL, c, *name;
+	struct lfile *lfp = NULL, *memberp = NULL;
+	int i, action = 0;
+
+	if (argc < 3)
+		usage();
+
+	p = argv[1];
+	if (*p == '-')
+		p++;
+
+	while ((c = *p++)) {
+		switch (c) {
+		case 'd': /* delete */
+		case 'p': /* print contents */
+		case 'q': /* append */
+		case 'r': /* insert and replace */
+		case 't': /* list */
+		case 'x': /* extract */
+			if (action && action != c)
+				usage();
+			action = c;
+			break;
+		case 'c':
+			creation_flag = 1;
+			break;
+		case 'v':
+			verbose_level = 1;
+			break;
+		default:
+			usage();
+		}
+	}
+
+	if (!action)
+		usage();
+
+	for (i=2; i<argc; ++i) {
+		p = argv[i];
+		if (strchr(basenam(p), ' ')) {
+			fprintf(stderr, "Error: filename '%s' contain a space character.\n", p);
+			exit(1);
+		}
+		if (!arname) {
+			arname = new(strlen(p)+1);
+			strcpy(arname, p);
+		}
+		else {
+			name = action == 'd' || action == 'x' ? basenam(p) : p;
+			if (!memberp) {
+				memberp = new_lfile(name, 0);
+				lfp = memberp;
+			}
+			else {
+				lfp->f_flp = new_lfile(name, 0);
+				lfp = lfp->f_flp;
+			}
+		}
+	}
+
+	if (!arname)
+		usage();
+
+	switch (action) {
+	case 'd': replace(arname, memberp, 1); break;
+	case 'p': extract(arname, memberp, 0); break;
+	case 'q': append(arname, memberp);     break;
+	case 'r': replace(arname, memberp, 0); break;
+	case 't': extract(arname, memberp, 1); break;
+	case 'x': extract(arname, memberp, 2); break;
+	}
+
+	return 0;
+}
diff --git a/asxv5pxx/libsrc/aslib.h b/asxv5pxx/libsrc/aslib.h
new file mode 100644
index 0000000..8271bb5
--- /dev/null
+++ b/asxv5pxx/libsrc/aslib.h
@@ -0,0 +1,56 @@
+/* aslib.h */
+
+/*
+ * Include Config File
+ */
+#include "../config.h"
+
+/*
+ * Local Definitions
+ */
+#define FSEPX '.'
+
+/*
+ * Case Sensitivity Flag
+ */
+#define CASE_SENSITIVE 1
+
+struct lfile
+{
+	char *f_idp;          /* Pointer to file spec */
+	struct lfile *f_flp;  /* lfile link */
+	char f_found;         /* Module found flag */
+	char f_arch;          /* Archive flag */
+};
+
+/*
+ * From ardata.c
+ */
+extern char *ip;
+extern char ib[NINPUT];
+extern char ctype[];
+#ifndef	CASE_SENSITIVE
+extern char ccase[];
+#endif
+extern struct lfile *filep;
+extern struct lfile *cfp;
+
+/*
+ * Misc. Defines
+ */
+#define SPACE  0000
+#define ETC    0000
+#define LETTER 0001
+#define DIGIT  0002
+#define BINOP  0004
+#define RAD2   0010
+#define RAD8   0020
+#define RAD10  0040
+#define RAD16  0100
+#define ILL    0200
+#define DGT2   DIGIT|RAD16|RAD10|RAD8|RAD2
+#define DGT8   DIGIT|RAD16|RAD10|RAD8
+#define DGT10  DIGIT|RAD16|RAD10
+#define LTR16  LETTER|RAD16
+
+/* EOF */
diff --git a/asxv5pxx/libsrc/common.c b/asxv5pxx/libsrc/common.c
new file mode 100644
index 0000000..42521f9
--- /dev/null
+++ b/asxv5pxx/libsrc/common.c
@@ -0,0 +1,200 @@
+/* common.c */
+
+
+static FILE *sfp = NULL;
+
+
+
+static void *new(unsigned int n)
+{
+	char *p;
+
+	p = (char *)calloc(n, sizeof(char));
+	if (!p) {
+		fprintf(stderr, "Error: out of space!\n");
+		exit(1);
+	}
+
+	return p;
+}
+
+
+
+static struct lfile *new_lfile(char *filename, char arch)
+{
+	struct lfile *lfilep;
+
+	lfilep = (struct lfile *)new(sizeof(struct lfile));
+	lfilep->f_idp = (char *)new(strlen(filename)+1);
+	strcpy(lfilep->f_idp, filename);
+	lfilep->f_arch = arch;
+
+	return lfilep;
+}
+
+
+
+/* striplineend:
+ *  Strip newline and carriage-return at end of line.
+ */
+static void striplineend(char *str)
+{
+	int i;
+	i = strlen(str);
+	if (i > 0) {
+		if (str[i-1] == '\n')
+			str[--i] = 0;
+		if (i > 0) {
+			if (str[--i] == '\r')
+				str[i] = 0;
+		}
+	}
+}
+
+
+
+/* skipheader:
+ *  Skip header and symbol index.
+ */
+static void skipheader(FILE *fp)
+{
+	char *str;
+	long offset = 0;
+	while (FGETS(ib, sizeof(ib), fp) != NULL) {
+		striplineend(ib);
+		/* process header */
+		if (*ib == '#') {
+			offset = FTELL(fp);
+			continue;
+		}
+		/* process symbol index */
+		do {
+			striplineend(ib);
+			str = strchr(ib, ' ');
+			if (!*ib || (str && strchr(str+1, ' '))) {
+				offset = FTELL(fp);
+				continue;
+			}
+			if (strncmp(ib, tag_libbeg, tag_libsz)) {
+				str = strchr(ib, ' ');
+				if (str)
+					*str = 0;
+				fprintf(stderr, "Error: wrong archive format '%s'.\n", ib);
+				exit(1);
+			}
+			break;
+		} while (FGETS(ib, sizeof(ib), fp) != NULL);
+		break;
+	}
+	if (FSEEK(fp, offset, SEEK_SET) < 0) {
+		fprintf(stderr, "Error: cannot seek archive.\n");
+		exit(1);
+	}
+}
+
+
+
+static int get(void)
+{
+	int c;
+
+	if ((c = *ip) != 0)
+		++ip;
+
+	return c;
+}
+
+
+
+static int getnb(void)
+{
+	int c;
+
+	while ((c=get())==' ');
+
+	return c;
+}
+
+
+
+static void getid(char *id, int c)
+{
+	char *p;
+
+	if (c < 0)
+		c = getnb();
+
+	p = id;
+
+	do {
+		if (p < &id[NCPS-1])
+			*p++ = c;
+	} while ((ctype[c=get()] & (LETTER|DIGIT)) || (c == '-'));
+
+	if (c != 0)
+		--ip;
+
+	*p = 0;
+}
+
+
+
+static long as_offset(void)
+{
+	return cfp->f_arch ? FTELL(sfp) : ftell(sfp);
+}
+
+
+
+static int nxtline(void)
+{
+	int ret;
+	ret = 1;
+
+loop:
+	if (sfp == NULL ||
+			(!cfp->f_arch && fgets(ib, sizeof(ib), sfp) == NULL) ||
+			 (cfp->f_arch && FGETS(ib, sizeof(ib), sfp) == NULL)) {
+		/* close just finished file */
+		if (sfp != NULL) {
+			if (!cfp->f_arch)
+				fclose(sfp);
+			else
+				FCLOSE(sfp);
+			sfp = NULL;
+		}
+
+		/* advance current file */
+		if (cfp == NULL)
+			cfp = filep;
+		else
+			cfp = cfp->f_flp;
+
+		/* open new file */
+		if (cfp != NULL) {
+#ifdef VERBOSE_LEVEL
+			if (verbose_level && verbose_action)
+				fprintf(stdout, "%c - %s\n", verbose_action, cfp->f_idp);
+#endif
+			if (!cfp->f_arch)
+				sfp = fopen(cfp->f_idp, "r");
+			else
+				sfp = FOPEN(cfp->f_idp, "r");
+			if (!sfp) {
+				fprintf(stderr, "Error: cannot open '%s'.\n", cfp->f_idp);
+				exit(1);
+			}
+			if (cfp->f_arch)
+				skipheader(sfp);
+			ret = 2;
+			goto loop;
+		}
+		else {
+			return 0;
+		}
+	}
+
+	striplineend(ib);
+
+	return ret;
+}
diff --git a/asxv5pxx/libsrc/nmmain.c b/asxv5pxx/libsrc/nmmain.c
new file mode 100644
index 0000000..0c3057a
--- /dev/null
+++ b/asxv5pxx/libsrc/nmmain.c
@@ -0,0 +1,133 @@
+/* nmmain.c */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "aslib.h"
+#define ZLIBARCH_STATIC
+#include "zlibarch.h"
+
+#include "common.c"
+
+
+
+/* dump:
+ *  Dumps the contents of the archive on stdout.
+ */
+static void dump(struct lfile *objp)
+{
+   char modname[32];
+   char area[32];
+   char label[32];
+   char type, c, t;
+   unsigned int val, val2;
+
+   filep = objp;
+   cfp = NULL;
+
+   modname[0] = '\0';
+   area[0] = '\0';
+   label[0] = '\0';
+
+   while (nxtline()) {
+      ip = ib;
+      c = getnb();
+      switch (c) {
+	 case 'S':
+	    sscanf(ib, "S %s %cef%x", label, &type, &val);
+	    if (type == 'D') {
+	       if (!strcmp(area, "_CODE"))
+		  t = 'T';
+	       else if (!strcmp(area, "_DATA"))
+		  t = 'D';
+	       else if (!strcmp(area, "_BSS"))
+		  t = 'B';
+	       else
+	          t = '?';
+	    }
+	    else {
+	       t = 'U';
+	    }
+
+	    printf("%04x %c %s\n", val & 0x0ffff, t, label);
+	    break;
+
+	 case 'A':
+	    sscanf(ib, "A %s size %x flags %x\n", area, &val, &val2);
+	    break;
+
+	 case 'H':
+	    break;
+
+	 case 'M':
+	    break;
+
+	 case 'L':
+	    c = getnb();
+	    if (c == '0') {
+	       getid(modname, -1);
+	       printf("\n%s:\n", modname);
+	    }
+	    break;
+      }
+   }
+}
+
+
+static char *usetxt[] = {
+   "Usage: objfile...",
+   NULL
+};
+
+
+
+static void usage(void)
+{
+   char **dp;
+
+   fprintf(stderr, "ASxxxx Object file Lister %s\n\n", VERSION);
+   for (dp = usetxt; *dp; dp++)
+      fprintf(stderr, "%s\n", *dp);
+
+   exit(1);
+}
+
+
+
+int main(int argc, char *argv[])
+{
+   struct lfile *lfp = NULL, *objp = NULL;
+   char *p, c;
+   int i;
+
+   if (argc < 2)
+      usage();
+
+   for (i=1; i<argc; ++i) {
+      p = argv[i];
+
+      if (*p == '-') {
+	 c = *++p;
+	 switch (c) {
+	    default:
+	       usage();
+         }
+      }
+      else {
+	 if (!objp) {
+	    objp = new_lfile(p, 0);
+	    lfp = objp;
+         }
+	 else {
+	    lfp->f_flp = new_lfile(p, 0);
+	    lfp = lfp->f_flp;
+	 }
+      }
+   }
+
+   if (!objp)
+      usage();
+
+   dump(objp);
+
+   return 0;
+}
diff --git a/asxv5pxx/linksrc/aslink.h b/asxv5pxx/linksrc/aslink.h
index ef485c2..0fbe370 100644
--- a/asxv5pxx/linksrc/aslink.h
+++ b/asxv5pxx/linksrc/aslink.h
@@ -29,28 +29,15 @@
 /*
  * System Include Files
  */
-
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <time.h>
 
 /*
- * Local Definitions
- */
-
-#define	VERSION "V05.11"
-#define	COPYRIGHT "2015"
-
-/*
- * To include NoICE Debugging set non-zero
+ * Include Config File
  */
-#define	NOICE	1
-
-/*
- * To include SDCC Debugging set non-zero
- */
-#define	SDCDB	1
+#include "../config.h"
 
 /*
  * The assembler requires certain variables to have
@@ -150,11 +137,11 @@
 /*
  *	.HLR Definitions from the Assemblers
  */
-#define NLIST	0		/* No listing */
-#define SLIST	1		/* Source only */
-#define ALIST	2		/* Address only */
+#define	NLIST	0		/* No listing */
+#define	SLIST	1		/* Source only */
+#define	ALIST	2		/* Address only */
 #define	BLIST	3		/* Address only with allocation */
-#define CLIST	4		/* Code */
+#define	CLIST	4		/* Code */
 #define	ELIST	5		/* Equate only */
 
 #define	LIST_ERR	0x0001	/* Error Code(s) */
@@ -195,17 +182,13 @@
  * This file defines the format of the
  * relocatable binary file.
  */
-
-#define NCPS		80	/* characters per symbol */
-#define	NINPUT		512	/* Input buffer size */
-#define	NHASH	     (1 << 6)	/* Buckets in hash table */
+#define	NHASH	     (1 << 8)	/* Buckets in hash table */
 #define	HMASK	    (NHASH - 1)	/* Hash mask */
 #define	NLPP		60	/* Lines per page */
 #define	NMAX		78	/* IXX/SXX/DBX Buffer Length */
-#define		IXXMAXBYTES	32	/* NMAX > (2 * IXXMAXBYTES) */
-#define		SXXMAXBYTES	32	/* NMAX > (2 * SXXMAXBYTES) */
-#define		DBXMAXBYTES	64	/* NMAX > (  DBXMAXBYTES  ) */
-#define	FILSPC		80	/* File spec length */
+#define	IXXMAXBYTES	32	/* NMAX > (2 * IXXMAXBYTES) */
+#define	SXXMAXBYTES	32	/* NMAX > (2 * SXXMAXBYTES) */
+#define	DBXMAXBYTES	64	/* NMAX > (  DBXMAXBYTES  ) */
 
 /*
  * NTXT must be defined to have the same value in
@@ -226,7 +209,7 @@
 /*
  * Default Page Length Mask
  */
-#define	DEFAULT_PMASK	0xFF	/* 256 Element Boundary / Length */ 
+#define	DEFAULT_PMASK	0xFF	/* 256 Element Boundary / Length */
 
 /*
  * Internal ASxxxx Version Variable
@@ -771,6 +754,10 @@ struct lbname {
 	char		*path;
 	char		*libfil;
 	char		*libspc;
+	FILE		*libfp;
+	long		begin;
+	long		*hashbin;
+	int		nhashbin;
 	int		f_obj;
 };
 
@@ -808,6 +795,8 @@ struct lbfile {
 	struct	lbfile	*next;
 	char		*libspc;
 	char		*relfil;
+	FILE		*libfp;
+	long		offset;
 	char		*filspc;
 	int		f_obj;
 };
@@ -980,6 +969,10 @@ extern	int	yflag;		/*	-y, enable SDCC Debug output
 				 */
 #endif
 
+extern	int	aflag;		/*	add only the first library found
+				 */
+extern	int	rflag;		/*	disallow multiple defined symbol
+				 */
 extern	int	pflag;		/*	print linker command file flag
 				 */
 extern	int	uflag;		/*	Listing relocation flag
@@ -1060,12 +1053,21 @@ extern	char	eqt_id[128];	/*	Area name for this ELIST line
 extern	struct lbpath *lbphead;	/*	pointer to the first
 				 *	library path structure
 				 */
+extern	struct lbpath *lbptail;	/*	pointer to the last
+				 *	library path structure
+				 */
 extern	struct lbname *lbnhead;	/*	pointer to the first
 				 *	library name structure
 				 */
+extern	struct lbname *lbntail;	/*	pointer to the last
+				 *	library name structure
+				 */
 extern	struct lbfile *lbfhead;	/*	pointer to the first
 				 *	library file structure
 				 */
+extern	struct lbfile *lbftail;	/*	pointer to the last
+				 *	library file structure
+				 */
 
 /* C Library function definitions */
 /* for reference only
@@ -1099,7 +1101,7 @@ extern	int		fndidx(char *str);
 extern	int		fndext(char *str);
 extern	VOID		gblsav(void);
 extern	int		intsiz(void);
-extern	VOID		link(void);
+extern	VOID		lklink(void);
 extern	VOID		lkexit(int i);
 extern	int		main(int argc, char *argv[]);
 extern	VOID		map(void);
@@ -1108,6 +1110,9 @@ extern	VOID		doparse(void);
 extern	VOID		setarea(void);
 extern	VOID		setgbl(void);
 extern	VOID		usage(int n);
+extern	VOID		lkerror(const char *format, ...);
+extern	VOID		lkwarning(const char *format, ...);
+extern	VOID		lkinfo(const char *format, ...);
 
 /* lklex.c */
 extern	VOID		chopcrlf(char *str);
@@ -1188,9 +1193,9 @@ extern	VOID		DefineEndFunction(a_uint value, struct bank *yp);
 extern	VOID		DefineLine(char *lineString, a_uint value, struct bank *yp);
 extern	VOID		PagedAddress(a_uint value, struct bank *yp);
 
-/* lksccdb.c */
+/* lksdcdb.c */
 extern	VOID		SDCDBfopen(void);
-extern	VOID		SDCDBcopy(char * str);
+extern	VOID		SDCDBcopy(char * str, struct lbfile *lbfh);
 extern	VOID		DefineSDCDB(char *name, a_uint value);
 
 /* lkrloc.c */
@@ -1243,12 +1248,12 @@ extern	VOID		relerr4(char *str);
 extern	VOID		relerp4(char *str);
 
 /* lklibr.c */
-extern	VOID		addfile(char *path, char *libfil);
+extern	int		addfile(char *path, char *libfil);
 extern	VOID		addlib(void);
 extern	VOID		addpath(void);
 extern	int		fndsym(char *name);
 extern	VOID		library(void);
-extern	VOID		loadfile(char *filspc);
+extern	VOID		loadfile(struct lbfile *lbfh);
 extern	VOID		search(void);
 
 /* lkout.c */
@@ -1274,7 +1279,7 @@ extern	int		fndext();
 extern	int		fndidx();
 extern	VOID		gblsav();
 extern	int		intsiz();
-extern	VOID		link();
+extern	VOID		lklink();
 extern	VOID		lkexit();
 extern	int		main();
 extern	VOID		map();
diff --git a/asxv5pxx/linksrc/lkarea.c b/asxv5pxx/linksrc/lkarea.c
index bf15ae4..26387a9 100644
--- a/asxv5pxx/linksrc/lkarea.c
+++ b/asxv5pxx/linksrc/lkarea.c
@@ -84,7 +84,7 @@
  *
  *	functions called:
  *		a_uint	eval()		lkeval.c
- *		VOID	exit()		c_library
+ *		VOID	lkerror()	lkmain.c
  *		int	fprintf()	c_library
  *		VOID	getid()		lklex.c
  *		VOID	lkparea()	lkarea.c
@@ -123,8 +123,7 @@ newarea()
 	char opt[NCPS];
 
 	if (headp == NULL) {
-		fprintf(stderr, "No header defined\n");
-		lkexit(ER_FATAL);
+		lkerror("No header defined");
 	}
 	/*
 	 * Create Area entry
@@ -161,8 +160,7 @@ newarea()
 				if (iflags) {
 			 		if (aflags & A4_OVR) {
 						if (iflags != (aflags & A4_OVR)) {
-							fprintf(stderr, "Conflicting CON/OVR flags in area %s\n", id);
-							lkerr++;
+							lkwarning("Conflicting CON/OVR flags in area %s\n", id);
 						}
 					} else {
 						ap->a_flag |= iflags;
@@ -172,8 +170,7 @@ newarea()
 				if (iflags) {
 			 		if (aflags & A4_ABS) {
 						if (iflags != (aflags & A4_ABS)) {
-							fprintf(stderr, "Conflicting REL/ABS flags in area %s\n", id);
-							lkerr++;
+							lkwarning("Conflicting REL/ABS flags in area %s\n", id);
 						}
 					} else {
 						ap->a_flag |= iflags;
@@ -183,8 +180,7 @@ newarea()
 				if (iflags) {
 			 		if (aflags & A4_PAG) {
 						if (iflags != (aflags & A4_PAG)) {
-							fprintf(stderr, "Conflicting NOPAG/PAG flags in area %s\n", id);
-							lkerr++;
+							lkwarning("Conflicting NOPAG/PAG flags in area %s\n", id);
 						}
 					} else {
 						ap->a_flag |= iflags;
@@ -194,8 +190,7 @@ newarea()
 					iflags = (int) (i & (A4_DSEG | A4_WLMSK));
 				 	if (aflags & A4_DSEG) {
 						if (iflags != (aflags & (A4_DSEG | A4_WLMSK))) {
-							fprintf(stderr, "Conflicting CSEG/DSEG flags in area %s\n", id);
-							lkerr++;
+							lkwarning("Conflicting CSEG/DSEG flags in area %s\n", id);
 						}
 					} else {
 						ap->a_flag |= iflags;
@@ -215,22 +210,18 @@ newarea()
 		if (symeq("bank", opt, 1)) {
 			hblp = hp->b_list;
 			if (hblp == NULL) {
-				fprintf(stderr, "No banks defined\n");
-				lkexit(ER_FATAL);
+				lkerror("No banks defined");
 			}
 			if (i >= (unsigned) hp->h_nbank) {
-				fprintf(stderr, "Invalid bank number\n");
-				lkexit(ER_FATAL);
+				lkerror("Invalid bank number");
 			}
 			if (hblp[(int) i] == NULL) {
-				fprintf(stderr, "Bank not defined\n");
-				lkexit(ER_FATAL);
+				lkerror("Bank not defined");
 			}
 			if (ap->a_bp != NULL) {
 				if (ap->a_bp != hblp[(int) i]) {
-					fprintf(stderr, "Multiple Bank assignments for area %s ( %s / %s )\n",
+					lkwarning("Multiple bank assignments for area %s ( %s / %s )\n",
 						id, ap->a_bp->b_id, hblp[(int) i]->b_id);
-					lkerr++;
 				}
 			} else {
 				ap->a_bp = hblp[(int) i];
@@ -253,8 +244,7 @@ newarea()
 			return;
 		}
 	}
-	fprintf(stderr, "Header area list overflow\n");
-	lkexit(ER_FATAL);
+	lkerror("Header area list overflow");
 }
 
 /*)Function	VOID	lkparea(id)
@@ -506,10 +496,9 @@ struct area *tap;
 	size = 0;
 	addr = tap->a_addr;
 	if (((tap->a_flag & A4_PAG) == A4_PAG) && (addr & 0xFF)) {
-	    fprintf(stderr,
-		"\n?ASlink-Warning-Paged Area %s Boundary Error\n",
+	    lkwarning(
+		"Paged area %s boundary error\n",
 		tap->a_id);
-	    lkerr++;
 	}
 	taxp = tap->a_axp;
 	if ((tap->a_flag & A4_OVR) == A4_OVR) {
@@ -535,10 +524,9 @@ struct area *tap;
 	}
 	tap->a_size = size;
 	if (((tap->a_flag & A4_PAG) == A4_PAG) && (size > 256)) {
-	    fprintf(stderr,
-		"\n?ASlink-Warning-Paged Area %s Length Error\n",
+	    lkwarning(
+		"Paged area %s length error\n",
 		tap->a_id);
-	    lkerr++;
 	}
 }
 
@@ -594,16 +582,14 @@ setarea()
 					break;
 			}
 			if (ap == NULL) {
-				fprintf(stderr,
+				lkwarning(
 				"No definition of area %s\n", id);
-				lkerr++;
 			} else {
 				ap->a_addr = v;
 				ap->a_bset = 1;
 			}
 		} else {
-			fprintf(stderr, "No '=' in base expression");
-			lkerr++;
+			lkwarning("No '=' in base expression\n");
 		}
 		bsp = bsp->b_base;
 	}
diff --git a/asxv5pxx/linksrc/lkbank.c b/asxv5pxx/linksrc/lkbank.c
index 1544314..4f772cf 100644
--- a/asxv5pxx/linksrc/lkbank.c
+++ b/asxv5pxx/linksrc/lkbank.c
@@ -69,7 +69,7 @@
  *
  *	functions called:
  *		a_uint	eval()		lkeval.c
- *		VOID	exit()		c_library
+ *		VOID	lkerror()	lkmain.c
  *		int	fprintf()	c_library
  *		VOID	getid()		lklex.c
  *		VOID	lkpbank()	lkbank.c
@@ -107,8 +107,7 @@ newbank()
 	struct bank **hblp;
 
 	if (headp == NULL) {
-		fprintf(stderr, "No header defined\n");
-		lkexit(ER_FATAL);
+		lkerror("No header defined");
 	}
 	/*
 	 * Create bank entry
@@ -129,8 +128,7 @@ newbank()
 				bp->b_base = v;
 			} else {
 				if (v && (bp->b_base != v)) {
-					fprintf(stderr, "Conflicting address in bank %s\n", id);
-					lkerr++;
+					lkwarning("Conflicting address in bank %s\n", id);
 				}
 			}
 		} else
@@ -143,8 +141,7 @@ newbank()
 				bp->b_size = v;
 			} else {
 				if (v && (bp->b_size != v)) {
-					fprintf(stderr, "Conflicting size in bank %s\n", id);
-					lkerr++;
+					lkwarning("Conflicting size in bank %s\n", id);
 				}
 			}
 		} else
@@ -157,8 +154,7 @@ newbank()
 				bp->b_map = v;
 			} else {
 				if (v && (bp->b_map != v)) {
-					fprintf(stderr, "Conflicting mapping in bank %s\n", id);
-					lkerr++;
+					lkwarning("Conflicting mapping in bank %s\n", id);
 				}
 			}
 		} else
@@ -171,8 +167,7 @@ newbank()
 				bp->b_flag = i;
 			} else {
 				if (i && (bp->b_flag != i)) {
-					fprintf(stderr, "Conflicting flags in bank %s\n", id);
-					lkerr++;
+					lkwarning("Conflicting flags in bank %s\n", id);
 				}
 			}
 		} else
@@ -186,8 +181,7 @@ newbank()
 					bp->b_fsfx = strsto(id);
 				} else {
 					if (!symeq(bp->b_fsfx, id, 1)) {
-						fprintf(stderr, "Conflicting fsfx in bank %s\n", id);
-						lkerr++;
+						lkwarning("Conflicting fsfx in bank %s\n", id);
 					}
 				}
 			}
@@ -204,8 +198,7 @@ newbank()
 			return;
 		}
 	}
-	fprintf(stderr, "Header bank list overflow\n");
-	lkexit(ER_FATAL);
+	lkerror("Header bank list overflow");
 }
 
 /*)Function	VOID	lkpbank(id)
@@ -382,6 +375,7 @@ VOID
 chkbank(fp)
 FILE *fp;
 {
+	char *msg;
 	a_uint alow, ahigh, blimit, bytes;
 
 	for (bp = bankp; bp != NULL; bp = bp->b_bp) {
@@ -411,9 +405,14 @@ FILE *fp;
 			}
 		}
 		if ((ahigh - alow) > blimit) {
-			fprintf(fp,
-			"\n?ASlink-Warning-Size limit exceeded in bank %s\n", bp->b_id);
-			lkerr++;
+			msg = "Size limit exceeded in bank %s\n";
+			if (fp == stderr) {
+				lkwarning(msg, bp->b_id);
+			}
+			else {
+				fputs("\n", fp);
+				fprintf(fp, msg, bp->b_id);
+			}
 		}
 	}
 }
@@ -435,7 +434,7 @@ FILE *fp;
  *		char *	frmt		temporary file type string
  *		char *	str[]		File Specification String
  *		struct bank *tbp	temporary bank pointer
- *
+ *		struct sym *sp		.__.END. symbol pointer
  *
  *	global variables:
  *		area	*ap		Pointer to the current
@@ -456,7 +455,7 @@ FILE *fp;
  *		FILE *	afile()		lkmain.c
  *		int	fclose()	c_library
  *		int	fprintf()	c_library
- *		VOID	lkexit()	lkmain.c
+ *		VOID	lkerror()	lkmain.c
  *		char *	strcpy()	c_library
  *		char *	strsto()	lksym.c
  *		char *	symeq()		lksym.c
@@ -561,7 +560,7 @@ lkfopen()
 				}
 				if (fp != stderr) {
 					if (fp == NULL) {
-						lkexit(ER_FATAL);
+						lkerror("Cannot create output file");
 					}
 					bp->b_ofspec = strsto(afspec);
 #if NOICE
diff --git a/asxv5pxx/linksrc/lkdata.c b/asxv5pxx/linksrc/lkdata.c
index 0676149..8413f62 100644
--- a/asxv5pxx/linksrc/lkdata.c
+++ b/asxv5pxx/linksrc/lkdata.c
@@ -80,6 +80,10 @@ int	mflag;		/*	Map output flag
 			 */
 int	xflag;		/*	Map file radix type flag
 			 */
+int	aflag;		/*	add only the first library found
+			 */
+int	rflag;		/*	disallow multiple defined symbol
+			 */
 int	pflag;		/*	print linker command file flag
 			 */
 int	uflag;		/*	Listing relocation flag
@@ -305,7 +309,7 @@ struct	head	*hp;	/*	Pointer to the current
  *	};
  */
 struct	bank	bank[1] = {
-    {	NULL,	"",	"",	0,	0,	0,	0,	"",	NULL,	0,	1	}
+    {	NULL,	"",	"",	0,	0,	0,	0,	"",	NULL,	0,	1,	0	}
 };
 
 struct	bank	*bankp = &bank[0];
@@ -494,6 +498,9 @@ struct	rerr	rerr;	/*	Structure containing the
 struct	lbpath	*lbphead;	/*	pointer to the first
 				 *	library path structure
 				 */
+struct	lbpath	*lbptail;	/*	pointer to the last
+				 *	library path structure
+				 */
 
 /*
  *	The structure lbname is created for all combinations of the
@@ -526,6 +533,9 @@ struct	lbpath	*lbphead;	/*	pointer to the first
 struct	lbname	*lbnhead;	/*	pointer to the first
 				 *	library name structure
 				 */
+struct	lbname	*lbntail;	/*	pointer to the last
+				 *	library name structure
+				 */
 
 /*
  *	The function fndsym() searches through all combinations of the
@@ -568,6 +578,9 @@ struct	lbname	*lbnhead;	/*	pointer to the first
 struct	lbfile	*lbfhead;	/*	pointer to the first
 				 *	library file structure
 				 */
+struct	lbfile	*lbftail;	/*	pointer to the last
+				 *	library file structure
+				 */
 
 /*
  *	array of character types, one per
diff --git a/asxv5pxx/linksrc/lkeval.c b/asxv5pxx/linksrc/lkeval.c
index 3189820..ed3ea74 100644
--- a/asxv5pxx/linksrc/lkeval.c
+++ b/asxv5pxx/linksrc/lkeval.c
@@ -147,8 +147,7 @@ int n;
 		if ((p = oprio(c)) <= n)
 			break;
 		if ((c == '>' || c == '<') && c != get()) {
-			fprintf(stderr, "Invalid expression");
-			lkerr++;
+			lkwarning("Invalid expression\n");
 			return(v);
 		}
 		ve = expr(p);
@@ -269,8 +268,7 @@ term()
 	if (c == '(') {
 		v = expr(0);
 		if (getnb() != ')') {
-			fprintf(stderr, "Missing delimiter");
-			lkerr++;
+			lkwarning("Missing delimiter\n");
 		}
 		return(v);
 	}
@@ -344,15 +342,13 @@ term()
 	if (ctype[c] & LETTER) {
 		getid(id, c);
 		if ((sp = lkpsym(id, 0)) == NULL) {
-			fprintf(stderr, "Undefined symbol %s\n", id);
-			lkerr++;
+			lkwarning("Undefined symbol %s\n", id);
 			return(0);
 		} else {
 			return(symval(sp));
 		}
 	}
-	fprintf(stderr, "Unknown operator %c\n", c);
-	lkerr++;
+	lkwarning("Unknown operator %c\n", c);
 	return(0);
 }
 
diff --git a/asxv5pxx/linksrc/lkhead.c b/asxv5pxx/linksrc/lkhead.c
index 71379aa..d508b76 100644
--- a/asxv5pxx/linksrc/lkhead.c
+++ b/asxv5pxx/linksrc/lkhead.c
@@ -199,7 +199,7 @@ newhead()
  *	functions called:
  *		a_uint	eval()		lkexpr.c
  *		int	fprintf()	c_library
- *		VOID	lkexit()	lkmain.c
+ *		VOID	lkerror()	lkmain.c
  *		int	more()		lklex.c
  *		char *	new()		lksym.c
  *
@@ -216,16 +216,14 @@ newmode()
 	struct mode *mp;
 
 	if (headp == NULL) {
-		fprintf(stderr, "No header defined\n");
-		lkexit(ER_FATAL);
+		lkerror("No header defined");
 	}
 	/*
 	 * Mode number
 	 */
 	n = (int) eval();
 	if (n >= hp->h_nmode) {
-		fprintf(stderr, "Header mode list overflow\n");
-		lkexit(ER_FATAL);
+		lkerror("Header mode list overflow");
 	}
 	/*
 	 * Bit index
@@ -306,7 +304,6 @@ module()
 		getid(id, -1);
 		hp->m_id = strsto(id);
 	} else {
-		fprintf(stderr, "No header defined\n");
-		lkerr++;
+		lkwarning("No header defined\n");
 	}
 }
diff --git a/asxv5pxx/linksrc/lklex.c b/asxv5pxx/linksrc/lklex.c
index af984f0..b32ed4d 100644
--- a/asxv5pxx/linksrc/lklex.c
+++ b/asxv5pxx/linksrc/lklex.c
@@ -411,7 +411,7 @@ int d;
  *		int	fprintf()	c_library
  *		VOID	gethlr()	lklist.c
  *		VOID	lkulist()	lklist.c
- *		VOID	lkexit()	lkmain.c
+ *		VOID	lkerror()	lkmain.c
  *		VOID	SDCDBcopy()	lksdcdb.c
  *
  *	side effects:
@@ -469,18 +469,17 @@ loop:	if (cfp && cfp->f_type == F_STD)
 
 #if SDCDB
 				if (sfp && (pass == 0)) {
-				  SDCDBcopy(fid);
+				  SDCDBcopy(fid, NULL);
 				}
 #endif
 
 				gline = 1;
 				hline = 1;
 			} else {
-				fprintf(stderr, "Invalid file type\n");
-				lkexit(ER_FATAL);
+				lkerror("Invalid file type");
 			}
 			if (sfp == NULL) {
-				lkexit(ER_FATAL);
+				lkerror(NULL);
 			}
 			goto loop;
 		} else {
@@ -581,6 +580,19 @@ VOID
 chopcrlf(str)
 char *str;
 {
+#ifdef __unix__
+	int len;
+
+	len = strlen(str);
+	if (len > 0) {
+		if (str[len-1] == '\n')
+			str[--len] = 0;
+		if (len > 0) {
+			if (str[--len] == '\r')
+				str[len] = 0;
+		}
+	}
+#else
 	char *p;
 	char c;
 
@@ -591,5 +603,6 @@ char *str;
 			p--;
 		}
 	} while (c != 0);
+#endif
 }
 
diff --git a/asxv5pxx/linksrc/lklibr.c b/asxv5pxx/linksrc/lklibr.c
index 2d58256..cbd54a3 100644
--- a/asxv5pxx/linksrc/lklibr.c
+++ b/asxv5pxx/linksrc/lklibr.c
@@ -26,9 +26,18 @@
  * Ken Hornstein
  * kenhat cmf dot nrl dot navy dot mil
  *
+ * Major update, support single file library,
+ * added support for gzip'ed library,
+ * added hash table and symbol index for
+ * a huge improvement in link time,
+ * contributions from
+ * David Flamand <dflamand@gmail.com>
+ *
  */
 
 #include "aslink.h"
+#define ZLIBARCH_STATIC
+#include "zlibarch.h"
 
 /*)Module	lklibr.c
  *
@@ -39,16 +48,45 @@
  *	    and link the module containing this symbol
  *
  *	lklibr.c contains the following functions:
+ *		int	djb2hash()
  *		VOID	addpath()
  *		VOID	addlib()
- *		VOID	addfile()
+ *		int	addfile()
  *		VOID	search()
+ *		VOID	processtag()
+ *		VOID	fndsym_noind()
+ *		VOID	fndsym_cache()
  *		VOID	fndsym()
  *		VOID	library()
  *		VOID	loadfile()
  *
  */
 
+/*)Function	int	djb2hash()
+ *
+ *		char	*p		input string
+ *
+ *	The function djb2hash() compute a hash on a string.
+ *
+ *	local variables:
+ *		int	h		hash value
+ *
+ *	side effects:
+ *		An hash is computed from string.
+ */
+
+static
+int
+djb2hash(p)
+char *p;
+{
+	int h;
+	h = 5381;
+	while (*p)
+		h = ((h << 5) + h) + *p++;
+	return h;
+}
+
 /*)Function	VOID	addpath()
  *
  *	The function addpath() creates a linked structure containing
@@ -56,40 +94,35 @@
  *
  *	local variables:
  *		lbpath	*lbph		pointer to new path structure
- *		lbpath	*lbp		temporary pointer
  *
  *	global variables:
  *		lbpath	*lbphead	The pointer to the first
  *				 	path structure
+ *		lbpath	*lbptail	The pointer to the last
+ *				 	path structure
  *
  *	 functions called:
+ *		char *	new()		lksym.c
+ *		char *	strto()		lksym.c
  *		int	getnb()		lklex.c
- *		VOID *	new()		lksym.c
- *		int	strlen()	c_library
- *		char *	strcpy()	c_library
  *		VOID	unget()		lklex.c
  *
  *	side effects:
- *		An lbpath structure may be created.
+ *		An lbpath structure is created.
  */
 
 VOID
 addpath()
 {
-	struct lbpath *lbph, *lbp;
+	struct lbpath *lbph;
 
 	lbph = (struct lbpath *) new (sizeof(struct lbpath));
-	if (lbphead == NULL) {
-		lbphead = lbph;
-	} else {
-		lbp = lbphead;
-		while (lbp->next)
-			lbp = lbp->next;
-		lbp->next = lbph;
-	}
+	if (lbphead == NULL)
+		lbphead = lbptail = lbph;
+	else
+		lbptail = lbptail->next = lbph;
 	unget(getnb());
-	lbph->path = (char *) new (strlen(ip)+1);
-	strcpy(lbph->path, ip);
+	lbph->path = strsto (ip);
 }
 
 /*)Function	VOID	addlib()
@@ -103,15 +136,18 @@ addpath()
  *
  *	local variables:
  *		lbpath	*lbph		pointer to path structure
+ *		int	libfnd		library found flag
  *
  *	global variables:
  *		lbpath	*lbphead	The pointer to the first
  *				 	path structure
+ *		int	aflag		library must exist flag
  *
  *	 functions called:
- *		VOID	addfile()	lklibr.c
+ *		int	addfile()	lklibr.c
  *		int	getnb()		lklex.c
  *		VOID	unget()		lklex.c
+ *		VOID	lkerror()	lkmain.c
  *
  *	side effects:
  *		The function addfile() may add the file to
@@ -122,19 +158,26 @@ VOID
 addlib()
 {
 	struct lbpath *lbph;
+	int libfnd = 0;
 
 	unget(getnb());
 
 	if (lbphead == NULL) {
-		addfile(NULL,ip);
-		return;
-	}	
-	for (lbph=lbphead; lbph; lbph=lbph->next) {
-		addfile(lbph->path,ip);
+		libfnd |= addfile(NULL,ip);
+	} else {
+		for (lbph=lbphead; lbph; lbph=lbph->next) {
+			libfnd |= addfile(lbph->path,ip);
+			if (aflag && libfnd)
+				break;
+		}
+	}
+
+	if (aflag && !libfnd) {
+		lkerror("Cannot find or open library \"%s\"", ip);
 	}
 }
 
-/*)Function	VOID	addfile(path,libfil)
+/*)Function	int	addfile(path,libfil)
  *
  *		char	*path		library path specification
  *		char	*libfil		library file specification
@@ -150,36 +193,57 @@ addlib()
  *	path / file specifications or if the file is not found.
  *
  *	local variables:
+ *		FILE *	fp		library file pointer
  *		lbname	*lbnh		pointer to new name structure
- *		lbname	*lbn		temporary pointer
  *		char *	str		path / file string
  *		char *	strend		end of path pointer
  *
  *	global variables:
  *		lbname	*lbnhead	The pointer to the first
  *				 	path structure
+ *		lbname	*lbntail	The pointer to the last
+ *				 	path structure
  *		int	objflg		linked file/library object output flag
  *
  *	 functions called:
- *		VOID *	malloc()	c_library
+ *		char *	new()		lksym.c
+ *		char *	strto()		lksym.c
+ *		VOID	free()		c_library
+ *		FILE *	fopen()		c_library
  *		int	strlen()	c_library
  *		char *	strcpy()	c_library
+ *		char *	strcat()	c_library
+ *		char *	strchr()	c_library
+ *		int	sprintf()	c_library
  *
  *	side effects:
  *		An lbname structure may be created.
  */
 
-VOID
+int
 addfile(path,libfil)
 char *path;
 char *libfil;
 {
 	FILE *fp;
+	struct lbname *lbnh;
 	char *str, *strend;
-	struct lbname *lbnh, *lbn;
-
-	if ((path != NULL) && (strchr(libfil,':') == NULL)){
-		str = (char *) malloc (strlen(path) + strlen(libfil) + 5);
+#ifdef __unix__
+	if ((path != NULL) && *path && *libfil != '/') {
+		str = new (strlen(path) + strlen(libfil) + 2);
+		strcpy(str,path);
+		strend = str + strlen(str) - 1;
+		if (*strend != '/') {
+			strend[1] = '/';
+			strend[2] = 0;
+		}
+		strcat(str,libfil);
+	} else {
+		str = strsto (libfil);
+	}
+#else
+	if ((path != NULL) && (strchr(libfil,':') == NULL)) {
+		str = new (strlen(path) + strlen(libfil) + 5);
 		strcpy(str,path);
 		strend = str + strlen(str) - 1;
 		if ((*libfil == '\\' && *strend == '\\') ||
@@ -188,32 +252,34 @@ char *libfil;
 		}
 		strcat(str,libfil);
 	} else {
-		str = (char *) malloc (strlen(libfil) + 5);
+		str = new (strlen(libfil) + 5);
 		strcpy(str,libfil);
 	}
-	if(strchr(str,FSEPX) == NULL) {
+	if (strchr(str,FSEPX) == NULL) {
 		sprintf(&str[strlen(str)], "%clib", FSEPX);
 	}
-	if ((fp = fopen(str, "r")) != NULL) {
-		fclose(fp);
+#endif
+	if ((fp = FOPEN(str, "r")) != NULL) {
 		lbnh = (struct lbname *) new (sizeof(struct lbname));
-		if (lbnhead == NULL) {
-			lbnhead = lbnh;
-		} else {
-			lbn = lbnhead;
-			while (lbn->next)
-				lbn = lbn->next;
-			lbn->next = lbnh;
-		}
-		if ((path != NULL) && (strchr(libfil,':') == NULL)){
+		if (lbnhead == NULL)
+			lbnhead = lbntail = lbnh;
+		else
+			lbntail = lbntail->next = lbnh;
+#ifdef __unix__
+		if ((path != NULL) && *libfil != '/')
 			lbnh->path = path;
-		}
-		lbnh->libfil = (char *) new (strlen(libfil) + 1);
-		strcpy(lbnh->libfil,libfil);
+#else
+		if ((path != NULL) && (strchr(libfil,':') == NULL))
+			lbnh->path = path;
+#endif
+		lbnh->libfil = strsto (libfil);
 		lbnh->libspc = str;
+		lbnh->libfp = fp;
 		lbnh->f_obj = objflg;
+		return 1;
 	} else {
 		free(str);
+		return 0;
 	}
 }
 
@@ -233,8 +299,8 @@ char *libfil;
  *	also resolved.
  *
  *	local variables:
- *		int	i		temporary counter
  *		sym	*sp		pointer to a symbol structure
+ *		int	i		temporary counter
  *		int	symfnd		found a symbol flag
  *
  *	global variables:
@@ -286,72 +352,278 @@ search()
 	}
 }
 
-/*)Function	VOID	fndsym(name)
+/*)Function	VOID	processtag()
  *
- *		char	*name		symbol name to find
+ *		char *	line		line to process
+ *		lbname	*lbnh		pointer to lbname structure
+ *		int *	phashptr	pointer to hash pointer
  *
- *	The function fndsym() searches through all combinations of the
- *	library path specifications (input by the -k option) and the
- *	library file specifications (input by the -l option) that
- *	lead to an existing file.
+ *	The function processtag() process a library tag of an
+ *	indexed library.  A library tag is any line that begin
+ *	with '#' and is followed by a tag at the begining of
+ *	a library.
  *
- *	The file specification may be formed in one of two ways:
+ *	local variables:
+ *		char *	str		string pointer
+ *		long *	hashbin		hash bin pointer
+ *		long	value		a value
+ *		int	nhashbin	number of hash bin minus one
+ *		int	hashptr		hash pointer
  *
- *	(1)	If the library file contained an absolute
- *		path/file specification then this becomes filspc.
- *		(i.e. C:\...)
+ *	 functions called:
+ *		int	strncmp()	c_library
+ *		int	strcmp()	c_library
+ *		long	strtol()	c_library
+ *		char *	strchr()	c_library
+ *		char *	new()		lksym.c
+ *		VOID	chopcrlf()	lklex.c
+ *		VOID	lkerror()	lkmain.c
  *
- *	(2)	If the library file contains a relative path/file
- *		specification then the concatenation of the path
- *		and this file specification becomes filspc.
- *		(i.e. \...)
+ *	side effects:
+ *		Process the tag, can throw an error if something is wrong.
+ */
+
+static
+VOID
+processtag(line, lbnh, phashptr)
+char *line;
+struct lbname *lbnh;
+int *phashptr;
+{
+	char *str;
+	long *hashbin, value;
+	int nhashbin, hashptr;
+	/* Proccess hash tag. */
+	if (!strncmp(line, " HASH ", sizeof(" HASH ")-1)) {
+		hashptr = *phashptr;
+		if (hashptr >= 0) {
+			str = line + sizeof(" HASH ") - 1 - 1;
+			if (!hashptr) {
+				value = strtol(++str, NULL, 16);
+				if (value < 0 || value > MAXHASHBIT)
+					lkerror("Bad hash size in library file \"%s\"", lbnh->libspc);
+				nhashbin = 1 << value;
+				lbnh->nhashbin = nhashbin;
+				hashptr = nhashbin > 1 ? 1 : -1;
+			}
+			if (hashptr > 0) {
+				if (lbnh->hashbin == NULL) {
+					lbnh->hashbin = (long*)new (sizeof(long)*lbnh->nhashbin);
+					lbnh->nhashbin--;
+				}
+				nhashbin = lbnh->nhashbin;
+				hashbin = lbnh->hashbin;
+				while (hashptr<=(nhashbin+1) && (str=strchr(str, ' '))) {
+					hashbin[hashptr-1] = strtol(++str, NULL, 16);
+					hashptr++;
+				}
+			}
+			*phashptr = hashptr;
+		}
+	}
+	/* Proccess format tag. */
+	else if (!strncmp(line, " FORMAT ", sizeof(" FORMAT ")-1)) {
+		str = line + sizeof(" FORMAT ") - 1;
+		chopcrlf(str);
+		if (strcmp(str, "DFAR"))
+			lkerror("Wrong format '%s' for library file \"%s\"", str, lbnh->libspc);
+	}
+	/* Proccess version tag. */
+	else if (!strncmp(line, " VERSION ", sizeof(" VERSION ")-1)) {
+		str = line + sizeof(" VERSION ") - 1;
+		value = strtol(str, NULL, 10);
+		if (value != 1)
+			lkerror("Wrong version '%li' for library file \"%s\"", value, lbnh->libspc);
+	}
+}
+
+/*)Function	int	fndsym_noind()
  *
- *	The structure lbfile is created for the first library
- *	object file which contains the definition for the
- *	specified undefined symbol.
+ *		lbname	*lbnh		pointer to lbname structure
+ *		char	*name		symbol name to find
  *
- *	If the library file [.LIB] contains file specifications for
- *	non existant files, no errors are returned.
+ *	The function fndsym_noind() searches for a symbol
+ *	in an unindexed library file, it return zero if
+ *	the symbol is not found or one if found.
  *
  *	local variables:
- *		char	buf[]		[.REL] file input line
- *		char	c		[.REL] file input character
- *		FILE	*fp		file handle for object file
- *		lbfile	*lbf		temporary pointer
+ *		FILE *	libfp		library file pointer
  *		lbfile	*lbfh		pointer to lbfile structure
- *		int	lbscan		scan library file flag
- *		FILE	*libfp		file handle for library file
+ *		char	obj[]		object name buffer
+ *		char	buf[]		line buffer
+ *		char	symname[]	symbol name
+ *		char 	c		character
+ *		long	offset		object offset
+ *		long	curoffset	object current offset
+ *
+ *	global variables:
+ *		int	obj_flag	linked file/library object output flag
+ *
+ *	 functions called:
+ *		int	fseek()		c_library
+ *		long	ftell()		c_library
+ *		char *	fgets()		c_library
+ *		char *	strcpy()	c_library
+ *		int	sscanf()	c_library
+ *		int	strncmp()	c_library
+ *		char *	new()		lksym.c
+ *		char *	strto()		lksym.c
+ *		VOID	chopcrlf()	lklex.c
+ *		VOID	loadfile()	lklibr.c
+ *		VOID	lkerror()	lkmain.c
+ *
+ *	side effects:
+ *		If the symbol is found then a new lbfile structure
+ *		is created and added to the linked list of lbfile
+ *		structures.  The library object module
+ *		containing the symbol will be imported and linked.
+ */
+
+int
+fndsym_noind(lbnh, name)
+struct lbname *lbnh;
+char *name;
+{
+	FILE *libfp;
+	struct lbfile *lbfh;
+	char obj[NINPUT];
+	char buf[NINPUT];
+	char symname[NINPUT], c;
+	long offset, curoffset;
+
+	/*
+	 * Set library file pointer to begin.
+	 */
+	libfp = lbnh->libfp;
+	if (FSEEK (libfp, lbnh->begin, SEEK_SET) != 0)
+		lkerror("Cannot seek library file \"%s\"", lbnh->libspc);
+
+	*obj = 0;
+	curoffset = offset = 0;
+	while (FGETS (buf, NINPUT, libfp) != NULL) {
+		chopcrlf(buf);
+
+		/*
+		 * Check for 'E' line, terminate if found.
+		 */
+		if (buf[0] == 'E')
+			break;
+
+		/*
+		 * Check for 'L' line.
+		 */
+		if (buf[0] == 'L') {
+			if (buf[1] == '0' && buf[2] == ' ') {
+				strcpy(obj, &buf[3]);
+				offset = curoffset;
+				curoffset = FTELL (libfp);
+			}
+			else if (buf[1] == '1' && buf[2] == ' ') {
+				*obj = 0;
+			}
+			curoffset = FTELL (libfp);
+			continue;
+		}
+
+		/*
+		 * Not between 'L0' and 'L1' line, so continue.
+		 */
+		if (*obj == 0)
+			continue;
+
+		/*
+		 * When a 'T line' is found terminate file scan.
+		 * All 'S lines' preceed 'T lines' in .REL files.
+		 */
+		if (buf[0] == 'T') {
+			*obj = 0;
+			continue;
+		}
+
+		/*
+		 * Skip everything that's not a symbol record.
+		 */
+		if (buf[0] != 'S')
+			continue;
+
+		sscanf(buf, "S %s %c", symname, &c);
+
+		/*
+		 * If we find a symbol definition for the
+		 * symbol we're looking for, load in the
+		 * file and add it to lbfhead so it gets
+		 * loaded on pass number 2.
+		 */
+		if (strncmp(symname, name, NCPS) == 0 && c == 'D') {
+			if (FSEEK (libfp, offset, SEEK_SET) != 0)
+				lkerror("Cannot seek library file \"%s\"", lbnh->libspc);
+			/* Add the object to lbfhead. */
+			lbfh = (struct lbfile *) new (sizeof(struct lbfile));
+			if (lbfhead == NULL)
+				lbfhead = lbftail = lbfh;
+			else
+				lbftail = lbftail->next = lbfh;
+			lbfh->libspc = lbnh->libspc;
+			lbfh->relfil = strsto (obj);;
+			lbfh->libfp = libfp;
+			lbfh->offset = offset;
+			lbfh->f_obj = lbnh->f_obj;
+			obj_flag = lbfh->f_obj;
+#if SDCDB
+			SDCDBcopy (NULL, lbfh);
+#endif
+			loadfile (lbfh);
+			return 1;
+		}
+
+	}
+	return 0;
+}
+
+/*)Function	int	fndsym_cache()
+ *
  *		lbname	*lbnh		pointer to lbname structure
- *		char	*path		file specification path
+ *		char	*name		symbol name to find
+ *
+ *	The function fndsym_cache() searches for a symbol
+ *	in a cache library file, it return zero if
+ *	the symbol is not found or one if found.
+ *
+ *	local variables:
+ *		FILE *	libfp		library file pointer
+ *		lbfile	*lbfh		pointer to lbfile structure
+ *		lbfile	*lbf		pointer to temporary lbfile structure
  *		char	relfil[]	[.REL] file specification
+ *		char	buf[]		line buffer
+ *		char	symname[]	[.REL] file symbol string
+ *		char	*path		file specification path
  *		char	*str		combined path and file specification
  *		char	*strend		end of path pointer
- *		char	symname[]	[.REL] file symbol string
+ *		char	c		[.REL] file input character
+ *		int	lbscan		scan library file flag
  *
  *	global variables:
- *		lbname	*lbnhead	The pointer to the first
- *				 	name structure
- *		lbfile	*lbfhead	The pointer to the first
- *				 	file structure
  *		int	obj_flag	linked file/library object output flag
  *
  *	 functions called:
- *		VOID	chopcrlf()	lklex.c
+ *		FILE *	fopen()		c_library
  *		int	fclose()	c_library
- *		int	fgets()		c_library
- *		FILE	*fopen()	c_library
+ *		int	fseek()		c_library
+ *		long	ftell()		c_library
+ *		char *	fgets()		c_library
  *		VOID	free()		c_library
- *		VOID	lkexit()	lkmain.c
- *		VOID	loadfile()	lklibr.c
- *		VOID *	malloc()	c_library
- *		char *	sprintf()	c_library
- *		int	sscanf()	c_library
- *		char *	strcat()	c_library
- *		char *	strchr()	c_library
  *		char *	strcpy()	c_library
+ *		char *	strcat()	c_library
  *		int	strlen()	c_library
+ *		int	sscanf()	c_library
+ *		int	sprintf()	c_library
+ *		int	strcmp()	c_library
  *		int	strncmp()	c_library
- *		VOID	unget()		lklex.c
+ *		char *	new()		lksym.c
+ *		char *	strto()		lksym.c
+ *		VOID	chopcrlf()	lklex.c
+ *		VOID	loadfile()	lklibr.c
+ *		VOID	lkerror()	lkmain.c
  *
  *	side effects:
  *		If the symbol is found then a new lbfile structure
@@ -361,65 +633,73 @@ search()
  */
 
 int
-fndsym(name)
+fndsym_cache(lbnh, name)
+struct lbname *lbnh;
 char *name;
 {
 	FILE *libfp, *fp;
-	struct lbname *lbnh;
 	struct lbfile *lbfh, *lbf;
 	char relfil[NINPUT+2];
 	char buf[NINPUT+2];
 	char symname[NINPUT];
-	char *path,*str,*strend;
-	char c;
+	char *path,*str,*strend,c;
 	int lbscan;
 
 	/*
-	 * Search through every library in the linked list "lbnhead".
+	 * Set library file pointer to 0.
 	 */
+	libfp = lbnh->libfp;
+	if (FSEEK (libfp, 0, SEEK_SET) != 0)
+		lkerror("Cannot seek library file \"%s\"", lbnh->libspc);
+	path = lbnh->path;
 
-/*1*/	for (lbnh=lbnhead; lbnh; lbnh=lbnh->next) {
-		if ((libfp = fopen(lbnh->libspc, "r")) == NULL) {
-			fprintf(stderr, "Cannot open library file %s\n",
-				lbnh->libspc);
-			lkexit(ER_FATAL);
+	/*
+	 * Read in a line from the library file.
+	 * This is the relative file specification
+	 * for a .REL file in this library.
+	 */
+	while (FGETS (relfil, NINPUT, libfp) != NULL) {
+		chopcrlf(relfil);
+#ifdef __unix__
+		if ((path != NULL) && *path && *relfil != '/') {
+			str = new (strlen(path) + strlen(relfil) + 2);
+			strcpy(str,path);
+			strend = str + strlen(str) - 1;
+			if (*strend != '/') {
+				strend[1] = '/';
+				strend[2] = 0;
+			}
+			strcat(str,relfil);
+		} else {
+			str = strsto (relfil);
 		}
-		path = lbnh->path;
-
-		/*
-		 * Read in a line from the library file.
-		 * This is the relative file specification
-		 * for a .REL file in this library.
-		 */
-
-/*2*/		while (fgets(relfil, NINPUT, libfp) != NULL) {
-		    relfil[NINPUT+1] = '\0';
-		    chopcrlf(relfil);
-		    if (path != NULL) {
-			str = (char *) malloc (strlen(path)+strlen(relfil)+5);
+#else
+		if (path != NULL) {
+			str = new (strlen(path)+strlen(relfil)+5);
 			strcpy(str,path);
 			strend = str + strlen(str) - 1;
 			if ((*relfil == '\\' && *strend == '\\') ||
-			    (*relfil ==  '/' && *strend ==  '/')) {
+				(*relfil ==  '/' && *strend ==  '/')) {
 				*strend = '\0';
 			}
 			strcat(str,relfil);
-		    } else {
-			str = (char *) malloc (strlen(relfil) + 5);
+		} else {
+			str = new (strlen(relfil) + 5);
 			strcpy(str,relfil);
-		    }
-		    if(strchr(str,FSEPX) == NULL) {
+		}
+		if(strchr(str,FSEPX) == NULL) {
 			sprintf(&str[strlen(str)], "%crel", FSEPX);
-		    }
-		    /*
-		     * Scan only files not yet loaded
-		     */
-		    for (lbf=lbfhead, lbscan=1; lbf&&lbscan; lbf=lbf->next) {
-			if (strcmp(lbf->filspc,str) == 0) {
-			    lbscan = 0;
+		}
+#endif
+		/*
+		 * Scan only files not yet loaded
+		 */
+		for (lbf=lbfhead, lbscan=1; lbf&&lbscan; lbf=lbf->next) {
+			if (lbf->filspc != NULL && strcmp(lbf->filspc,str) == 0) {
+				lbscan = 0;
 			}
-		    }
-/*3*/		    if (lbscan && (fp = fopen(str, "r")) != NULL) {
+		}
+		if (lbscan && (fp = FOPEN(str, "r")) != NULL) {
 
 			/*
 			 * Read in the object file.  Look for lines that
@@ -428,70 +708,242 @@ char *name;
 			 * if it is our symbol.  Make sure we only read in
 			 * our object file and don't go into the next one.
 			 */
-			
-/*4*/			while (fgets(buf, NINPUT, fp) != NULL) {
-
-			buf[NINPUT+1] = '\0';
-			chopcrlf(buf);
+			while (FGETS (buf, NINPUT, fp) != NULL) {
+				chopcrlf(buf);
 
-			/*
-			 * When a 'T line' is found terminate file scan.
-			 * All 'S lines' preceed 'T lines' in .REL files.
-			 */
-			if (buf[0] == 'T')
-				break;
-
-			/*
-			 * Skip everything that's not a symbol record.
-			 */
-			if (buf[0] != 'S')
-				continue;
+				/*
+				 * When a 'T line' is found terminate file scan.
+				 * All 'S lines' preceed 'T lines' in .REL files.
+				 */
+				if (buf[0] == 'T')
+					break;
 
-			sscanf(buf, "S %s %c", symname, &c);
+				/*
+				 * Skip everything that's not a symbol record.
+				 */
+				if (buf[0] != 'S')
+					continue;
 
-			/*
-			 * If we find a symbol definition for the
-			 * symbol we're looking for, load in the
-			 * file and add it to lbfhead so it gets
-			 * loaded on pass number 2.
-			 */
-/*5*/			if (strncmp(symname, name, NCPS) == 0 && c == 'D') {
+				sscanf(buf, "S %s %c", symname, &c);
 
-			lbfh = (struct lbfile *) new (sizeof(struct lbfile));
-			if (lbfhead == NULL) {
-				lbfhead = lbfh;
-			} else {
-				lbf = lbfhead;
-				while (lbf->next)
-					lbf = lbf->next;
-				lbf->next = lbfh;
-			}
-			lbfh->libspc = lbnh->libspc;
-			lbfh->filspc = str;
-			lbfh->relfil = (char *) new (strlen(relfil) + 1);
-			strcpy(lbfh->relfil,relfil);
-			lbfh->f_obj = lbnh->f_obj;
-			fclose(fp);
-			fclose(libfp);
-			obj_flag = lbfh->f_obj;
+				/*
+				 * If we find a symbol definition for the
+				 * symbol we're looking for, load in the
+				 * file and add it to lbfhead so it gets
+				 * loaded on pass number 2.
+				 */
+				if (strncmp(symname, name, NCPS) == 0 && c == 'D') {
 
+					lbfh = (struct lbfile *) new (sizeof(struct lbfile));
+					if (lbfhead == NULL)
+						lbfhead = lbftail = lbfh;
+					else
+						lbftail = lbftail->next = lbfh;
+					lbfh->libspc = lbnh->libspc;
+					lbfh->filspc = str;
+					lbfh->relfil = strsto (relfil);
+					lbfh->f_obj = lbnh->f_obj;
+					FCLOSE (fp);
+					obj_flag = lbfh->f_obj;
 #if SDCDB
-			SDCDBcopy(str);
+					SDCDBcopy (NULL, lbfh);
 #endif
+					loadfile (lbfh);
+					return 1;
+
+				}
 
-			loadfile(str);
-			return (1);
+			}
+			FCLOSE (fp);
+		}
+		free (str);
+	}
+	return 0;
+}
+
+/*)Function	VOID	fndsym(name)
+ *
+ *		char	*name		symbol name to find
+ *
+ *	The function fndsym() searches through all combinations of the
+ *	library path specifications (input by the -k option) and the
+ *	library file specifications (input by the -l option) that
+ *	lead to an existing file.
+ *
+ *	The file specification may be formed in one of two ways:
+ *
+ *	(1)	If the library file contained an absolute
+ *		path/file specification then this becomes filspc.
+ *		(i.e. C:\...)
+ *
+ *	(2)	If the library file contains a relative path/file
+ *		specification then the concatenation of the path
+ *		and this file specification becomes filspc.
+ *		(i.e. \...)
+ *
+ *	The structure lbfile is created for the first library
+ *	object file which contains the definition for the
+ *	specified undefined symbol.
+ *
+ *	If the library file [.LIB] contains file specifications for
+ *	non existant files, no errors are returned.
+ *
+ *	local variables:
+ *		FILE	*libfp		file handle for library file
+ *		lbname	*lbnh		pointer to lbname structure
+ *		lbfile	*lbfh		pointer to lbfile structure
+ *		char	symname[]	line input buffer / symbol name
+ *		char	*obj		object file name
+ *		char	*offstr		object offset string
+ *		char	first		first line flag
+ *		long	begin		file offset of symbol index
+ *		long	offset		file offset of object
+ *		int	hashptr		hash table pointer
+ *
+ *	global variables:
+ *		lbname	*lbnhead	The pointer to the first
+ *				 	name structure
+ *		lbfile	*lbfhead	The pointer to the first
+ *				 	file structure
+ *		int	obj_flag	linked file/library object output flag
+ *
+ *	 functions called:
+ *		int	fseek()		c_library
+ *		int	fgets()		c_library
+ *		long	ftell()		c_library
+ *		VOID	loadfile()	lklibr.c
+ *		char *	new()		lksym.c
+ *		char *	strto()		lksym.c
+ *		char *	strchr()	c_library
+ *		int	strcmp()	c_library
+ *		VOID	processtag()	lklibr.c
+ *		VOID	fndsym_cache()	lklibr.c
+ *		VOID	fndsym_noind()	lklibr.c
+ *		VOID	lkerror()	lkmain.c
+ *
+ *	side effects:
+ *		If the symbol is found then a new lbfile structure
+ *		is created and added to the linked list of lbfile
+ *		structures.  The file containing the found symbol
+ *		is linked.
+ */
 
-/*5*/			}
+int
+fndsym(name)
+char *name;
+{
+	FILE *libfp;
+	struct lbname *lbnh;
+	struct lbfile *lbfh;
+	char symname[NINPUT];
+	char *obj,*offstr,first;
+	long begin, offset;
+	int hashptr;
 
-/*4*/			}
-		    fclose(fp);
-/*3*/		    }
-		    free(str);
-/*2*/		}
-		fclose(libfp);
-/*1*/	}
-	return(0);
+	/* Search through every library in the linked list "lbnhead". */
+	for (lbnh=lbnhead; lbnh; lbnh=lbnh->next) {
+		first = 0;
+		offset = 0;
+		hashptr = 0;
+		libfp = lbnh->libfp;
+		begin = lbnh->begin;
+		if (FSEEK (libfp, begin, SEEK_SET) != 0)
+			lkerror("Cannot seek library file \"%s\"", lbnh->libspc);
+		/* Parse header/metadata/comments at the begining. */
+		while (FGETS (symname, NINPUT, libfp) != NULL) {
+			if (*symname == '#') {
+				/* Proccess header tag. */
+				processtag(symname+1, lbnh, &hashptr);
+				first = 1;
+				begin = FTELL(libfp);
+				/* Should not happen, skip to next. */
+				if (begin <= 0)
+					break;
+				lbnh->begin = begin;
+				continue;
+			}
+			else {
+				if (*symname != '\n') {
+					obj = strchr(symname, ' ');
+					/* If the first line contain no separator and first char */
+					/* is not '#', then the format is a cache library. */
+					if (first == 0) {
+						first = 1;
+						if (obj == NULL) {
+							if (fndsym_cache(lbnh, name))
+								return 1;
+							break;
+						}
+					}
+					/* If the line contain one separators, */
+					/* then the format is an unindexed library. */
+					if (obj && !strchr(obj+1, ' ')) {
+						if (fndsym_noind(lbnh, name))
+							return 1;
+						break;
+					}
+				}
+			}
+			/* Have an hash table? if so seek to to proper location. */
+			if (lbnh->hashbin) {
+				offset = lbnh->hashbin[djb2hash(name)&lbnh->nhashbin];
+				/* Offset zero mean no symbol for that bin, therefore skip. */
+				if (offset == 0)
+					break;
+				if (FSEEK (libfp, begin+offset, SEEK_SET) != 0)
+					lkerror("Cannot seek library file \"%s\"", lbnh->libspc);
+				if (FGETS (symname, NINPUT, libfp) == NULL)
+					break;
+			}
+			/* Scan through all symbols. */
+			do {
+				/* Scan object name, space char is the separator. */
+				obj = strchr(symname, ' ');
+				/* Separator not found, skip to the next file. */
+				if (obj == NULL)
+					break;
+				*obj++ = 0;
+				/* Symbol name match ? */
+				if (strcmp(symname, name) == 0) {
+					/* Seek object offset, space char is the separator. */
+					offstr = strchr(obj, ' ');
+					/* Space not found, something wrong with the lib file,
+					   skip to the next file. */
+					if (offstr == NULL)
+						break;
+					*offstr++ = 0;
+					/* Convert offset string to long */
+					offset = strtol(offstr, NULL, 16);
+					/* Should not happen. */
+					if (offset <= 0)
+						break;
+					offset += begin;
+					/* Again should not happen. */
+					if (offset <= 0)
+						break;
+					/* Add the object to lbfhead. */
+					lbfh = (struct lbfile *) new (sizeof(struct lbfile));
+					if (lbfhead == NULL)
+						lbfhead = lbftail = lbfh;
+					else
+						lbftail = lbftail->next = lbfh;
+					lbfh->libspc = lbnh->libspc;
+					lbfh->relfil = strsto (obj);
+					lbfh->libfp = libfp;
+					lbfh->offset = offset;
+					lbfh->f_obj = lbnh->f_obj;
+					obj_flag = lbfh->f_obj;
+#if SDCDB
+					SDCDBcopy (NULL, lbfh);
+#endif
+					loadfile (lbfh);
+					return 1;
+				}
+			} while (FGETS (symname, NINPUT, libfp) != NULL);
+			break;
+		}
+	}
+	return 0;
 }
 
 /*)Function	VOID	library()
@@ -520,19 +972,18 @@ library()
 
 	for (lbfh=lbfhead; lbfh; lbfh=lbfh->next) {
 		obj_flag = lbfh->f_obj;
-		loadfile(lbfh->filspc);
+		loadfile(lbfh);
 	}
 }
 
-/*)Function	VOID	loadfile(filspc)
+/*)Function	VOID	loadfile(lbfh)
  *
- *		char	*filspc		library object file specification
+ *		lbfile	*lbfh		pointer to lbfile structure
  *
  *	The function loadfile() links the library object module.
  *
  *	local variables:
  *		FILE	*fp		file handle
- *		int	i		input line length
  *		char	str[]		file input line
  *
  *	global variables:
@@ -543,25 +994,60 @@ library()
  *		int	fclose()	c_library
  *		int	fgets()		c_library
  *		FILE *	fopen()		c_library
- *		VOID	link()		lkmain.c
+ *		int	fseek()		c_library
+ *		int	ferror()	c_library
+ *		VOID	lklink()	lkmain.c
+ *		VOID	lkerror()	lkmain.c
  *
  *	side effects:
  *		If file exists it is linked.
  */
 
 VOID
-loadfile(filspc)
-char *filspc;
+loadfile(lbfh)
+struct lbfile *lbfh;
 {
 	FILE *fp;
 	char str[NINPUT];
 
-	if ((fp = fopen(filspc,"r")) != NULL) {
-		while (fgets(str, sizeof(str), fp) != NULL) {
-			chopcrlf(str);
-			ip = str;
-			link();
+	if (lbfh->filspc == NULL) {
+		/* The object is embedded in a library file. */
+
+		fp = lbfh->libfp;
+
+		/* Make sure the object is enclosed by 'L0' and 'L1' line. */
+		if (FSEEK(fp, lbfh->offset, SEEK_SET) == 0) {
+			if (FGETS(str, sizeof(str), fp) != NULL) {
+				if (str[0] == 'L' && str[1] == '0') {
+					while (FGETS(str, sizeof(str), fp) != NULL) {
+						if (str[0] == 'L' && str[1] == '1')
+							return;
+						chopcrlf(str);
+						ip = str;
+						lklink();
+					}
+				}
+			}
 		}
-		fclose(fp);
+
+		lkerror("%s object \"%s\" in library \"%s\"",
+			FERROR(fp) ? "Failed to read" : "Wrong format for",
+			lbfh->relfil, lbfh->libspc);
+
+	} else {
+		/* The object is in an external file. */
+
+		if ((fp = FOPEN(lbfh->filspc,"r")) != NULL) {
+			while (FGETS(str, sizeof(str), fp) != NULL) {
+				chopcrlf(str);
+				ip = str;
+				lklink();
+			}
+			FCLOSE(fp);
+		}
+
+		if (fp == NULL || FERROR(fp))
+			lkerror("Failed to read \"%s\"", lbfh->filspc);
+
 	}
 }
diff --git a/asxv5pxx/linksrc/lklist.c b/asxv5pxx/linksrc/lklist.c
index 004d6b0..5060d47 100644
--- a/asxv5pxx/linksrc/lklist.c
+++ b/asxv5pxx/linksrc/lklist.c
@@ -59,7 +59,7 @@
  *	local variables:
  *		char *	frmt		string format
  *		char	np[]		new page string
- *		char	tp[]		temporary string	
+ *		char	tp[]		temporary string
  *
  *	global variables:
  *		time_t	curtim		current time string pointer
@@ -85,7 +85,7 @@ FILE *fp;
 	 *12345678901234567890123456789012345678901234567890123456789012345678901234567890
 	 *ASxxxx Linker Vxx.xx                                                    Page 1
 	 */
- 	/*
+	/*
 	 * Total newpag() string length is 78 characters.
 	 */
 	sprintf(np, "ASxxxx Linker %-64s", VERSION);
@@ -97,7 +97,11 @@ FILE *fp;
 	/*
 	 * Output string.
 	 */
+#if NOFORMFEED
+	fprintf(fp, "%s\n", np);
+#else
 	fprintf(fp, "\f%s\n", np);
+#endif
 	/*
 	 *12345678901234567890123456789012345678901234567890123456789012345678901234567890
 	 *Hexadecimal [16-Bits]                                 Sun Sep 15 17:22:25 2013
@@ -342,10 +346,10 @@ struct bank *yp;
 			}
 			putc('\n', mfp);
 			for(i=0;i<n;++i)
-				fprintf(mfp, "%s", frmta);
+				fputs(frmta, mfp);
 			putc('\n', mfp);
 			for(i=0;i<n;++i)
-				fprintf(mfp, "%s", frmtb);
+				fputs(frmtb, mfp);
 			putc('\n', mfp);
 		}
 
@@ -506,7 +510,7 @@ struct bank *yp;
 			case 3:
 			case 4: frmt = "   "; break;
 			}
-			fprintf(mfp, "%s", frmt);
+			fputs(frmt, mfp);
 		} else
 		if ((i % n) == 0) {
 			slew(xp, yp);
@@ -516,7 +520,7 @@ struct bank *yp;
 			case 3:
 			case 4: frmt = "  "; break;
 			}
-			fprintf(mfp, "%s", frmt);
+			fputs(frmt, mfp);
 		}
 
 		sp = p[i];
@@ -1237,8 +1241,8 @@ loop:	if (gline) {
 	/*
 	 * Fix 'u' if [nn], cycles, is specified
 	 */
-	 if (rb[a + (s*u) - 1] == CYCNT_END) {
-	 	u -= 1;
+	if (rb[a + (s*u) - 1] == CYCNT_END) {
+		u -= 1;
 	}
 	/*
 	 * Output text line when updates finished
@@ -1734,7 +1738,7 @@ int err;
 	int a, n, m, r, s, u;
 	int i, j;
 
- 	/*
+	/*
 	 * Exit if listing file is not open
 	 */
 	if (tfp == NULL)
@@ -1861,8 +1865,8 @@ loop:	if (hline) {
 	/*
 	 * Fix 'u' if [nn], cycles, is specified
 	 */
-	 if (rb[a + (s*u) - 1] == CYCNT_END) {
-	 	u -= 1;
+	if (rb[a + (s*u) - 1] == CYCNT_END) {
+		u -= 1;
 	}
 	/*
 	 * Must have an address
diff --git a/asxv5pxx/linksrc/lkmain.c b/asxv5pxx/linksrc/lkmain.c
index 645ef05..e4d7cef 100644
--- a/asxv5pxx/linksrc/lkmain.c
+++ b/asxv5pxx/linksrc/lkmain.c
@@ -23,6 +23,7 @@
  */
 
 #include "aslink.h"
+#include <stdarg.h>
 
 /*)Module	lkmain.c
  *
@@ -37,7 +38,7 @@
  *		VOID	bassav()
  *		VOID	gblsav()
  *		int	intsiz()
- *		VOID	link()
+ *		VOID	lklink()
  *		VOID	lkexit()
  *		int	fndext()
  *		int	fndidx()
@@ -47,6 +48,9 @@
  *		VOID	doparse()
  *		VOID	setgbl()
  *		VOID	usage()
+ *		VOID	lkerror()
+ *		VOID	lkwarning()
+ *		VOID	lkinfo()
  *
  *	lkmain.c contains the following local variables:
  *		char *	usetext[]	array of pointers to the
@@ -119,7 +123,7 @@
  *		int	fclose()	c_library
  *		int	fprintf()	c_library
  *		VOID	library()	lklibr.c
- *		VOID	link()		lkmain.c
+ *		VOID	lklink()	lkmain.c
  *		VOID	lkexit()	lkmain.c
  *		VOID	lkfopen()	lkbank.c
  *		VOID	lnkarea()	lkarea.c
@@ -136,6 +140,7 @@
  *		VOID	symdef()	lksym.c
  *		time_t	time()		c_library
  *		VOID	usage()		lkmain.c
+ *		VOID	lkerror()	lkmain.c
  *
  *	side effects:
  *		Completion of main() completes the linking process
@@ -152,12 +157,9 @@ char *argv[];
 	int c, i, j, k;
 
 	if (intsiz() < 4) {
-		fprintf(stderr, "?ASlink-Error-Size of INT32 is not 32 bits or larger.\n\n");
-		exit(ER_FATAL);
+		lkerror("Size of INT32 is not 32 bits or larger");
 	}
 
-	fprintf(stdout, "\n");
-
 	startp = (struct lfile *) new (sizeof (struct lfile));
 	startp->f_idp = "";
 
@@ -190,6 +192,8 @@ char *argv[];
 
 				case 'f':
 				case 'F':
+					if (i+1 >= argc)
+						lkerror("Missing argument to option -%c", c);
 					strcat(ip, " ");
 					strcat(ip, argv[++i]);
 					break;
@@ -263,7 +267,7 @@ char *argv[];
 
 		while (nxtline()) {
 			ip = ib;
-			link();
+			lklink();
 		}
 		if (pass == 0) {
 			/*
@@ -391,9 +395,9 @@ int i;
 	exit(i);
 }
 
-/*)Function	link()
+/*)Function	lklink()
  *
- *	The function link() evaluates the directives for each line of
+ *	The function lklink() evaluates the directives for each line of
  *	text read from the .rel file(s).  The valid directives processed
  *	are:
  *		X, D, Q, H, G, B, M, A, S, T, R, and P.
@@ -433,7 +437,7 @@ int i;
  */
 
 VOID
-link()
+lklink()
 {
 	int c;
 
@@ -658,7 +662,7 @@ map()
 	 */
 	mfp = afile(linkp->f_idp, "map", 1);
 	if (mfp == NULL) {
-		lkexit(ER_FATAL);
+		lkerror(NULL);
 	}
 
 	/*
@@ -732,7 +736,11 @@ map()
 			gsp = gsp->g_globl;
 		}
 	}
+#if NOFORMFEED
+	fprintf(mfp, "\n");
+#else
 	fprintf(mfp, "\n\f");
+#endif
 	chkbank(mfp);
 	symdef(mfp);
 }
@@ -761,6 +769,8 @@ map()
  *		int	mflag		Map output flag
  *		int	oflag		Output file type flag
  *		int	objflg		Linked file/library output object flag
+ *		int	aflag		add only the first library found
+ *		int	rflag		disallow multiple defined symbol
  *		int	pflag		print linker command file flag
  *		FILE *	stderr		c_library
  *		int	uflag		Relocated listing flag
@@ -779,7 +789,6 @@ map()
  *		VOID	getfid()	lklex.c
  *		int	get()		lklex.c
  *		int	getnb()		lklex.c
- *		int	getnb()		lklex.c
  *		VOID	lkexit()	lkmain.c
  *		char *	new()		lksym.c
  *		char *	strsto()	lksym.c
@@ -898,6 +907,16 @@ parse()
 					pflag = 0;
 					break;
 
+				case 'a':
+				case 'A':
+					aflag = 1;
+					break;
+
+				case 'r':
+				case 'R':
+					rflag = 1;
+					break;
+
 				case 'p':
 				case 'P':
 					pflag = 1;
@@ -941,8 +960,7 @@ parse()
 					break;
 
 				default:
-					fprintf(stderr,
-					    "Unkown option -%c ignored\n", c);
+					lkinfo("Unkown option -%c ignored", c);
 					break;
 				}
 			}
@@ -986,8 +1004,7 @@ parse()
 			lfp->f_idx = fndidx(p);
 			lfp->f_obj = objflg;
 		} else {
-			fprintf(stderr, "Invalid input");
-			lkexit(ER_FATAL);
+			lkerror("Invalid input");
 		}
 	}
 	return(0);
@@ -1112,6 +1129,7 @@ bassav()
  *				 	globl structure
  *		char	*ip		pointer into the REL file
  *				 	text line in ib[]
+ *		int	lkerr		error flag
  *
  *	functions called:
  *		int	getnb()		lklex.c
@@ -1189,22 +1207,19 @@ setgbl()
 			v = (int) expr(0);
 			sp = lkpsym(id, 0);
 			if (sp == NULL) {
-				fprintf(stderr,
+				lkwarning(
 				"No definition of symbol %s\n", id);
-				lkerr++;
 			} else {
 				if (sp->s_type & S_DEF) {
-					fprintf(stderr,
+					lkwarning(
 					"Redefinition of symbol %s\n", id);
-					lkerr++;
 					sp->s_axp = NULL;
 				}
 				sp->s_addr = v;
 				sp->s_type |= S_DEF;
 			}
 		} else {
-			fprintf(stderr, "No '=' in global expression");
-			lkerr++;
+			lkwarning("No '=' in global expression\n");
 		}
 		gsp = gsp->g_globl;
 	}
@@ -1268,8 +1283,7 @@ int wf;
 	FILE *fp;
 
 	if (strlen(fn) > (FILSPC-7)) {
-		fprintf(stderr, "?ASlink-Error-<filspc to long> : \"%s\"\n", fn);
-		lkerr++;
+		lkwarning("Filename to long: \"%s\"\n", fn);
 		return(NULL);
 	}
 
@@ -1322,10 +1336,9 @@ int wf;
 	}
 	if ((fp = fopen(afspec, frmt)) == NULL) {
 		if (wf < 4) {
-			fprintf(stderr, "?ASlink-Error-<cannot %s> : \"%s\"\n", (frmt[0] == 'w')?"create":"open", afspec);
-			lkerr++;
+			lkwarning("Cannot %s \"%s\"\n", (frmt[0] == 'w')?"create":"open", afspec);
 		} else {
-			fprintf(stderr, "?ASlink-Warning-<cannot %s> : \"%s\"\n", (frmt[0] == 'w')?"create":"open", afspec);
+			lkinfo("Cannot %s \"%s\"\n", (frmt[0] == 'w')?"create":"open", afspec);
 		}
 	}
 	return (fp);
@@ -1420,7 +1433,8 @@ char *usetxt[] = {
 	"Alternates to Command Line Input:",
 	"  -c                   ASlink >> prompt input",
 	"  -f   file[.lnk]      Command File input",
-	"Librarys:",
+	"Libraries:",
+	"  -a   Add only the first library found",
 	"  -k   Library path specification, one per -k",
 	"  -l   Library file specification, one per -l",
 	"Relocation:",
@@ -1446,7 +1460,8 @@ char *usetxt[] = {
 	"  -v   Linked file/library object output disable",
 	"List:",
 	"  -u   Update listing file(s) with link data as file(s)[.rst]",
-	"Case Sensitivity:",
+	"Symbols:",
+	"  -r   Disable Multiple Defined Symbols",
 	"  -z   Disable Case Sensitivity for Symbols",
 	"End:",
 	"  -e   or null line terminates input",
@@ -1479,12 +1494,69 @@ VOID
 usage(n)
 int n;
 {
-	char	**dp;
+	char **dp;
 
-	fprintf(stderr, "\nASxxxx Linker %s", VERSION);
-	fprintf(stderr, "\nCopyright (C) %s  Alan R. Baldwin", COPYRIGHT);
-	fprintf(stderr, "\nThis program comes with ABSOLUTELY NO WARRANTY.\n\n");
+	fprintf(stderr, "ASxxxx Linker " VERSION "\n");
+	fprintf(stderr, "Copyright (C) " COPYRIGHT " Alan R. Baldwin\n");
+	fprintf(stderr, "This program comes with ABSOLUTELY NO WARRANTY.\n\n");
 	for (dp = usetxt; *dp; dp++)
 		fprintf(stderr, "%s\n", *dp);
 	lkexit(n);
 }
+
+/*)Function	VOID	lkerror(const char *format, ...)
+ *
+ *		const char * format	string format
+ *		...			parameters if any
+ *
+*/
+
+VOID
+lkerror(const char *format, ...)
+{
+	if (format != NULL) {
+		va_list ap;
+		fprintf(stderr, "?ASlink-Error: ");
+		va_start(ap, format);
+		vfprintf(stderr, format, ap);
+		va_end(ap);
+		fprintf(stderr, "\n");
+	}
+	lkexit(ER_FATAL);
+}
+
+/*)Function	VOID	lkwarning(const char *format, ...)
+ *
+ *		const char * format	string format
+ *		...			parameters if any
+ *
+*/
+
+VOID
+lkwarning(const char *format, ...)
+{
+	va_list ap;
+	fprintf(stderr, "?ASlink-Warning: ");
+	va_start(ap, format);
+	vfprintf(stderr, format, ap);
+	va_end(ap);
+	lkerr++;
+}
+
+/*)Function	VOID	lkinfo(const char *format, ...)
+ *
+ *		const char * format	string format
+ *		...			parameters if any
+ *
+*/
+
+VOID
+lkinfo(const char *format, ...)
+{
+	va_list ap;
+	fprintf(stderr, "?ASlink-Info: ");
+	va_start(ap, format);
+	vfprintf(stderr, format, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
diff --git a/asxv5pxx/linksrc/lknoice.c b/asxv5pxx/linksrc/lknoice.c
index 79a4b88..18964ab 100644
--- a/asxv5pxx/linksrc/lknoice.c
+++ b/asxv5pxx/linksrc/lknoice.c
@@ -88,7 +88,7 @@ static char currentFunction[NCPS];
  *
  *	functions called:
  *		FILE *	afile()		lkmain.c
- *		VOID	lkexit()	lkmain.c
+ *		VOID	lkerror()	lkmain.c
  *
  *	side effects:
  *		The NoICE output file is opened.
@@ -101,7 +101,7 @@ VOID NoICEfopen(void)
 	if (jflag) {
 		jfp = afile(linkp->f_idp, "noi", 1);
 		if (jfp == NULL) {
-			lkexit(1);
+			lkerror("Cannot create NoICE file");
 		}
 		mflag = 1;
 	}
@@ -240,7 +240,8 @@ void DefineNoICE( char *name, a_uint value, struct bank *yp )
 	char token2[NCPS];
 	char token3[NCPS];
 	char sep1, sep2;
-	int  j, k, level;
+	int  j, k;
+	unsigned int level;
 	struct noicefn *np;
 
 	/* no output if file is not open */
diff --git a/asxv5pxx/linksrc/lkrloc.c b/asxv5pxx/linksrc/lkrloc.c
index 6accedd..3e445e8 100644
--- a/asxv5pxx/linksrc/lkrloc.c
+++ b/asxv5pxx/linksrc/lkrloc.c
@@ -88,8 +88,7 @@ int c;
 		break;
 
 	default:
-		fprintf(stderr, "Internal Version Error");
-		lkexit(ER_FATAL);
+		lkerror("Internal version error");
 		break;
 	}
 }
diff --git a/asxv5pxx/linksrc/lkrloc3.c b/asxv5pxx/linksrc/lkrloc3.c
index 29ae3bd..8df8c02 100644
--- a/asxv5pxx/linksrc/lkrloc3.c
+++ b/asxv5pxx/linksrc/lkrloc3.c
@@ -102,8 +102,7 @@ int c;
 		break;
 
 	default:
-		fprintf(stderr, "Undefined Relocation Operation\n");
-		lkerr++;
+		lkwarning("Undefined relocation operation");
 		break;
 
 	}
@@ -285,8 +284,7 @@ relr3()
 	 * Verify Area Mode
 	 */
 	if (eval() != R3_AREA || eval()) {
-		fprintf(stderr, "R input error\n");
-		lkerr++;
+		lkwarning("R input error\n");
 		return;
 	}
 
@@ -295,8 +293,7 @@ relr3()
 	 */
 	aindex = (int) evword();
 	if (aindex >= hp->h_narea) {
-		fprintf(stderr, "R area error\n");
-		lkerr++;
+		lkwarning("R area error\n");
 		return;
 	}
 
@@ -348,15 +345,13 @@ relr3()
 		 */
 		if (mode & R3_SYM) {
 			if (rindex >= hp->h_nsym) {
-				fprintf(stderr, "R symbol error\n");
-				lkerr++;
+				lkwarning("R symbol error\n");
 				return;
 			}
 			reli = symval(s[rindex]);
 		} else {
 			if (rindex >= hp->h_narea) {
-				fprintf(stderr, "R area error\n");
-				lkerr++;
+				lkwarning("R area error\n");
 				return;
 			}
 			reli = a[rindex]->a_addr;
@@ -663,8 +658,7 @@ relp3()
 	 * Verify Area Mode
 	 */
 	if (eval() != R3_AREA || eval()) {
-		fprintf(stderr, "P input error\n");
-		lkerr++;
+		lkwarning("P input error\n");
 	}
 
 	/*
@@ -672,8 +666,7 @@ relp3()
 	 */
 	aindex = (int) evword();
 	if (aindex >= hp->h_narea) {
-		fprintf(stderr, "P area error\n");
-		lkerr++;
+		lkwarning("P area error\n");
 		return;
 	}
 
@@ -690,15 +683,13 @@ relp3()
 		 */
 		if (mode & R3_SYM) {
 			if (rindex >= hp->h_nsym) {
-				fprintf(stderr, "P symbol error\n");
-				lkerr++;
+				lkwarning("P symbol error\n");
 				return;
 			}
 			relv = symval(s[rindex]);
 		} else {
 			if (rindex >= hp->h_narea) {
-				fprintf(stderr, "P area error\n");
-				lkerr++;
+				lkwarning("P area error\n");
 				return;
 			}
 			relv = a[rindex]->a_addr;
@@ -711,15 +702,14 @@ relp3()
 	 */
 	aindex = (int) adb_xb(0, a_bytes);
 	if (aindex >= hp->h_narea) {
-		fprintf(stderr, "P area error\n");
-		lkerr++;
+		lkwarning("P area error\n");
 		return;
 	}
 	sdp.s_areax = a[aindex];
 	sdp.s_area = sdp.s_areax->a_bap;
 	sdp.s_addr = adb_xb(0,a_bytes*2);
 	if (sdp.s_area->a_addr & 0xFF || sdp.s_addr & 0xFF)
-		relerp3("Page Definition Boundary Error");
+		relerp3("Page definition boundary error");
 }
 
 /*)Function	VOID	rele3()
@@ -837,14 +827,17 @@ char *str;
 	/*
 	 * Print Error
 	 */
-	fprintf(fptr, "\n?ASlink-Warning-%s", str);
-	lkerr++;
+	if (fptr == stderr) {
+		lkwarning(str);
+	} else {
+		fprintf(fptr, "\n%s", str);
+	}
 
 	/*
 	 * Print symbol if symbol based
 	 */
 	if (mode & R3_SYM) {
-		fprintf(fptr, " for symbol  %s\n",
+		fprintf(fptr, " for symbol %s\n",
 			&s[rindex]->s_id[0]);
 	} else {
 		fprintf(fptr, "\n");
@@ -878,7 +871,7 @@ char *str;
 /*        |                 |                 |                 |           */
 	fprintf(fptr,
 "  Defin  %-14.14s    %-14.14s    %-14.14s    ",
-			raxp->a_bhp->h_lfile->f_idp,
+			raxp->a_bhp->h_lfile ? raxp->a_bhp->h_lfile->f_idp : "",
 			&raxp->a_bhp->m_id[0],
 			&raxp->a_bap->a_id[0]);
 	if (mode & R3_SYM) {
@@ -954,8 +947,12 @@ char *str;
 	/*
 	 * Print Error
 	 */
-	fprintf(fptr, "\n?ASlink-Warning-%s\n", str);
-	lkerr++;
+	if (fptr == stderr) {
+		lkwarning(str);
+	} else {
+		fprintf(fptr, "\n%s", str);
+	}
+	fprintf(fptr, "\n");
 
 	/*
 	 * Print PgDef Info
@@ -963,7 +960,7 @@ char *str;
 /*         111111111122222222223333333333444444444455555555556666666666777*/
 /*123456789012345678901234567890123456789012345678901234567890123456789012*/
 	fprintf(fptr,
-"         file              module            pgarea            pgoffset\n");
+"         file              module            pgarea               pgoffset\n");
 	fprintf(fptr,
 "  PgDef  %-14.14s    %-14.14s    %-14.14s    ",
 			thp->h_lfile->f_idp,
diff --git a/asxv5pxx/linksrc/lkrloc4.c b/asxv5pxx/linksrc/lkrloc4.c
index 1900ba9..ad5bef1 100644
--- a/asxv5pxx/linksrc/lkrloc4.c
+++ b/asxv5pxx/linksrc/lkrloc4.c
@@ -112,8 +112,7 @@ int c;
 		break;
 
 	default:
-		fprintf(stderr, "Undefined Relocation Operation\n");
-		lkerr++;
+		lkwarning("Undefined relocation operation\n");
 		break;
 
 	}
@@ -307,8 +306,7 @@ relr4()
 	 * Verify Area Mode
 	 */
 	if (eval() != R4_AREA || eval()) {
-		fprintf(stderr, "R input error\n");
-		lkerr++;
+		lkwarning("R input error\n");
 		return;
 	}
 
@@ -317,8 +315,7 @@ relr4()
 	 */
 	aindex = (int) evword();
 	if (aindex >= hp->h_narea) {
-		fprintf(stderr, "R area error\n");
-		lkerr++;
+		lkwarning("R area error\n");
 		return;
 	}
 
@@ -392,15 +389,13 @@ relr4()
 		 */
 		if (mode & R4_SYM) {
 			if (rindex >= hp->h_nsym) {
-				fprintf(stderr, "R symbol error\n");
-				lkerr++;
+				lkwarning("R symbol error\n");
 				return;
 			}
 			reli = symval(s[rindex]);
 		} else {
 			if (rindex >= hp->h_narea) {
-				fprintf(stderr, "R area error\n");
-				lkerr++;
+				lkwarning("R area error\n");
 				return;
 			}
 			reli = a[rindex]->a_addr;
@@ -853,8 +848,7 @@ relp4()
 	 * Verify Area Mode
 	 */
 	if ((eval() != R4_AREA) || eval()) {
-		fprintf(stderr, "P input error\n");
-		lkerr++;
+		lkwarning("P input error\n");
 	}
 
 	/*
@@ -862,8 +856,7 @@ relp4()
 	 */
 	aindex = (int) evword();
 	if (aindex >= hp->h_narea) {
-		fprintf(stderr, "P area error\n");
-		lkerr++;
+		lkwarning("P area error\n");
 		return;
 	}
 
@@ -880,15 +873,13 @@ relp4()
 		 */
 		if (mode & R4_SYM) {
 			if (rindex >= hp->h_nsym) {
-				fprintf(stderr, "P symbol error\n");
-				lkerr++;
+				lkwarning("P symbol error\n");
 				return;
 			}
 			relv = symval(s[rindex]);
 		} else {
 			if (rindex >= hp->h_narea) {
-				fprintf(stderr, "P area error\n");
-				lkerr++;
+				lkwarning("P area error\n");
 				return;
 			}
 			relv = a[rindex]->a_addr;
@@ -901,8 +892,7 @@ relp4()
 	 */
 	aindex = (int) adb_xb(0,a_bytes);
 	if (aindex >= hp->h_narea) {
-		fprintf(stderr, "P area error\n");
-		lkerr++;
+		lkwarning("P area error\n");
 		return;
 	}
 	sdp.s_areax = a[aindex];
@@ -912,7 +902,7 @@ relp4()
 		p_mask = adb_xb(0,a_bytes*3);
 	}
 	if (sdp.s_area->a_addr & p_mask || sdp.s_addr & p_mask)
-		relerp4("Page Definition Boundary Error");
+		relerp4("Page definition boundary error");
 }
 
 /*)Function	VOID	rele4()
@@ -1030,14 +1020,17 @@ char *str;
 	/*
 	 * Print Error
 	 */
-	fprintf(fptr, "\n?ASlink-Warning-%s", str);
-	lkerr++;
+	if (fptr == stderr) {
+		lkwarning(str);
+	} else {
+		fprintf(fptr, "\n%s", str);
+	}
 
 	/*
 	 * Print symbol if symbol based
 	 */
 	if (mode & R4_SYM) {
-		fprintf(fptr, " for symbol  %s\n",
+		fprintf(fptr, " for symbol %s\n",
 			&s[rindex]->s_id[0]);
 	} else {
 		fprintf(fptr, "\n");
@@ -1071,7 +1064,7 @@ char *str;
 /*        |                 |                 |                 |           */
 	fprintf(fptr,
 "  Defin  %-14.14s    %-14.14s    %-14.14s    ",
-			raxp->a_bhp->h_lfile->f_idp,
+			raxp->a_bhp->h_lfile ? raxp->a_bhp->h_lfile->f_idp : "",
 			&raxp->a_bhp->m_id[0],
 			&raxp->a_bap->a_id[0]);
 	if (mode & R4_SYM) {
@@ -1147,8 +1140,12 @@ char *str;
 	/*
 	 * Print Error
 	 */
-	fprintf(fptr, "\n?ASlink-Warning-%s\n", str);
-	lkerr++;
+	if (fptr == stderr) {
+		lkwarning(str);
+	} else {
+		fprintf(fptr, "\n%s", str);
+	}
+	fprintf(fptr, "\n");
 
 	/*
 	 * Print PgDef Info
@@ -1187,7 +1184,7 @@ char *str;
  *
  *	functions called:
  *		int	fprintf()	c_library
- *		VOID	lkexit()	lkmain.c
+ *		VOID	lkerror()	lkmain.c
  *
  *	side effects:
  *		none
@@ -1203,8 +1200,7 @@ a_uint base;
 	a_uint m;
 
 	if ((mp = hp->m_list[r]) == NULL) {
-		fprintf(stderr, "undefined G mode\n");
-		lkexit(ER_FATAL);
+		lkerror("Undefined G mode");
 	}
 
 	if (mp->m_flag) {
diff --git a/asxv5pxx/linksrc/lksdcdb.c b/asxv5pxx/linksrc/lksdcdb.c
index 33c8570..e75cc10 100644
--- a/asxv5pxx/linksrc/lksdcdb.c
+++ b/asxv5pxx/linksrc/lksdcdb.c
@@ -54,7 +54,7 @@
  *
  *	functions called:
  *		FILE *	afile()		lkmain.c
- *		VOID	lkexit()	lkmain.c
+ *		VOID	lkerror()	lkmain.c
  *
  *	side effects:
  *		The SDCDB output file is opened.
@@ -67,7 +67,7 @@ VOID SDCDBfopen(void)
 	if (yflag) {
 		yfp = afile(linkp->f_idp, "cdb", 1);
 		if (yfp == NULL) {
-			lkexit(1);
+			lkerror("Cannot create SDCDB file");
 		}
 		mflag = 1;
 	}
@@ -76,7 +76,8 @@ VOID SDCDBfopen(void)
 
 /*)Function	VOID	SDCDBcopy()
  * 
- *		char *	str		pointer to the file spec
+ *		char *	str             pointer to the file spec
+ *		lbfile	*lbfh		pointer to lbfile structure
  *
  *	The function SDCDBcopy() copies an existing cdb file
  *	into the linker cdb file.
@@ -86,6 +87,10 @@ VOID SDCDBfopen(void)
  *	local variables:
  *		FILE *	xfp		file handle
  *		char	line[]		line from file
+ *		char *	sep		filename separator
+ *		char *	filename	cdb file name
+ *		int	len		string length
+ *		int	len2		string length 2
  *
  *	global variables:
  *		int	yflag		SDCDB Debug flag
@@ -102,27 +107,56 @@ VOID SDCDBfopen(void)
  *		the linker cdb output file.
  */
 
-VOID SDCDBcopy(str)
+VOID SDCDBcopy(str, lbfh)
 char * str;
+struct lbfile *lbfh;
 {
 	FILE * xfp;
-	char line[NINPUT];
+	char line[NINPUT], *sep, *filename;
+	int len, len2;
 
 	/*
 	 * Copy cdb file if present and requested.
 	 */
 	if (yflag && yfp) {
-		xfp = afile(str,"cdb",0);
-		if (xfp) {
-			while (fgets(line, sizeof(line), xfp) != NULL) {
-				fprintf(yfp, "%s", line);
+
+		if (str == NULL && lbfh->filspc == NULL) {
+
+			filename = NULL;
+
+#ifdef __unix__
+			sep = strrchr(lbfh->libspc, '/');
+#else
+			sep = strrchr(lbfh->libspc, '\\');
+#endif
+			len = sep ? sep - lbfh->libspc + 1 : 0;
+			if (len < NINPUT-1) {
+				strncpy(line, lbfh->libspc, len);
+				len2 = snprintf(&line[len], NINPUT-len, "%s", lbfh->relfil);
+				if (len2 > 0 && len+len2 < NINPUT-1) {
+					filename = line;
+				}
+			}
+
+		} else {
+
+			filename = str ? str : lbfh->filspc;
+
+		}
+
+		if (filename != NULL) {
+			xfp = afile(filename,"cdb",0);
+			if (xfp) {
+				while (fgets(line, sizeof(line), xfp) != NULL) {
+					fprintf(yfp, "%s", line);
+				}
+				fclose(xfp);
 			}
-			fclose(xfp);
 		}
+
 	}
 }
 
-
 /*)Function	VOID	DefineSDCDB()
  * 
  *		char *	name		pointer to the symbol string
diff --git a/asxv5pxx/linksrc/lksym.c b/asxv5pxx/linksrc/lksym.c
index 11fc20f..bbe673f 100644
--- a/asxv5pxx/linksrc/lksym.c
+++ b/asxv5pxx/linksrc/lksym.c
@@ -114,7 +114,7 @@ syminit()
  *
  *	functions called:
  *		a_uint	eval()		lkeval.c
- *		VOID	exit()		c_library
+ *		VOID	lkerror()	lkmain.c
  *		int	fprintf()	c_library
  *		int	get()		lklex.c
  *		int	getnb()		lklex.c
@@ -148,8 +148,7 @@ newsym()
 	char id[NCPS];
 
 	if (headp == NULL) {
-		fprintf(stderr, "No header defined\n");
-		lkexit(ER_FATAL);
+		lkerror("No header defined");
 	}
 	/*
 	 * Create symbol entry
@@ -160,17 +159,14 @@ newsym()
 	if (c == 'R') {
 		tsp->s_type |= S_REF;
 		if (eval()) {
-			fprintf(stderr, "Non zero S_REF\n");
-			lkerr++;
+			lkwarning("Non zero S_REF\n");
 		}
 	} else
 	if (c == 'D') {
 		ev = eval();
 		if (tsp->s_type & S_DEF) {
-			if (tsp->s_addr != ev) {
-				fprintf(stderr,
-					"Multiple definition of %s\n", id);
-				lkerr++;
+			if (tsp->s_addr != ev || (rflag && !symeq(id, ".__.ABS.", zflag))) {
+				lkwarning("Multiple definition of %s\n", id);
 			}
 		}
 		/*
@@ -181,8 +177,7 @@ newsym()
 		tsp->s_type |= S_DEF;
 		tsp->m_id = hp->m_id;
 	} else {
-		fprintf(stderr, "Invalid symbol type %c for %s\n", c, id);
-		lkexit(ER_FATAL);
+		lkerror("Invalid symbol type %c for %s", c, id);
 	}
 	/*
 	 * Place pointer in header symbol list
@@ -195,8 +190,7 @@ newsym()
 			return(tsp);
 		}
 	}
-	fprintf(stderr, "Header symbol list overflow\n");
-	lkexit(ER_FATAL);
+	lkerror("Header symbol list overflow");
 	return(NULL);
 }
 
@@ -378,13 +372,17 @@ struct sym *tsp;
 		p = hp->s_list;
 		for (i=0; i<hp->h_nsym; ++i) {
 		    if (p[i] == tsp) {
-			fprintf(fp,
-				"\n?ASlink-Warning-Undefined Global %s ",
-				tsp->s_id);
-			fprintf(fp,
-				"referenced by module %s\n",
-				hp->m_id);
-			lkerr++;
+			if (fp == stderr) {
+				lkwarning(
+					"Undefined symbol %s "
+					"referenced by module %s\n",
+					tsp->s_id, hp->m_id);
+			} else {
+				fprintf(fp,
+					"\nUndefined symbol %s "
+					"referenced by module %s\n",
+					tsp->s_id, hp->m_id);
+			}
 		    }
 		}
 	    hp = hp->h_hp;
@@ -477,21 +475,21 @@ hash(p, cflag)
 char *p;
 int cflag;
 {
-	int h;
+	unsigned char h;
 
-	h = 0;
-	while (*p) {
-		if(cflag) {
-			/*
-			 * Case Insensitive Hash
-			 */
-			h += ccase[*p++ & 0x007F];
-		} else {
-			/*
-			 * Case Sensitive Hash
-			 */
-			h += *p++;
-		}
+	h = 6;
+	if (cflag) {
+		/*
+		 * Case Insensitive Hash
+		 */
+		while (*p)
+			h = ((h << 5) + h) + ccase[*p++ & 0x007F];
+	} else {
+		/*
+		 * Case Sensitive Hash
+		 */
+		while (*p)
+			h = ((h << 5) + h) + *p++;
 	}
 	return (h&HMASK);
 }
@@ -642,8 +640,7 @@ unsigned int n;
 		bytes -= n;
 	}
 	if (p == NULL) {
-		fprintf(stderr, "Out of space!\n");
-		lkexit(ER_FATAL);
+		lkerror("Out of space");
 	}
 	for (i=0,q=p; i<n; i++) {
 		*q++ = 0;
@@ -651,7 +648,7 @@ unsigned int n;
 	return (p);
 }
 
-#else
+#elif !defined(__GLIBC__)
 
 /*)Function	char *	strsto(str)
  *
@@ -758,8 +755,7 @@ unsigned int n;
 	unsigned int i;
 
 	if ((p = (char *) malloc(n)) == NULL) {
-		fprintf(stderr, "Out of space!\n");
-		lkexit(ER_FATAL);
+		lkerror("Out of space");
 	}
 	for (i=0,q=p; i<n; i++) {
 		*q++ = 0;
@@ -767,4 +763,28 @@ unsigned int n;
 	return (p);
 }
 
+#else
+
+
+char *
+strsto(str)
+char *str;
+{
+	char *p;
+	if ((p = strdup(str)) == NULL)
+		lkerror("Out of space");
+	return p;
+}
+
+char *
+new(n)
+unsigned int n;
+{
+	char *p;
+	if ((p = (char *)calloc(1, n)) == NULL)
+		lkerror("Out of space");
+	return p;
+}
+
+
 #endif
diff --git a/asxv5pxx/readme.txt b/asxv5pxx/readme.txt
index 8434be7..44c92e3 100644
--- a/asxv5pxx/readme.txt
+++ b/asxv5pxx/readme.txt
@@ -19,7 +19,7 @@ for  the   assemblers  and   linker   is   included   with   the
 distribution.  Additionally, test code  for  each assembler  and
 several microprocessor monitors (ASSIST05  for the  6805, MONDEB
 and  ASSIST09  for the 6809, and  BUFFALO 2.5  for the 6811) are
-included  as  working examples  of use of these assemblers.  
+included  as  working examples  of use of these assemblers.
 
 asxv5p10.zip	ASxxxx and ASlink V5.10 Zipped
 
@@ -80,13 +80,13 @@ The Make or Build Exectutable directories are:
 
 
  Documentation in pdf form is
- 	\asxv5pxx\asxhtml\asmlnk.pdf
+	\asxv5pxx\asxhtml\asmlnk.pdf
 
  Documentation in plain text form is
- 	\asxv5pxx\asxhtml\asmlnk.txt
+	\asxv5pxx\asxhtml\asmlnk.txt
 
  Documentation in HTML form may be found starting with
- 	\asxv5pxx\asxhtml\asxxxx.htm
+	\asxv5pxx\asxhtml\asxxxx.htm
 
 
 /*
-- 
2.19.1.windows.1

