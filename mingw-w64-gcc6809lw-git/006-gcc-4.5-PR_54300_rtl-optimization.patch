From c0fff2d95361acb0f1b8d0bb97b4cc9b714cb956 Mon Sep 17 00:00:00 2001
From: rearnsha <rearnsha@138bc75d-0d04-0410-961f-82ee72b054a4>
Date: Wed, 20 Nov 2013 13:55:04 +0000
Subject: core: register copy propagation issue:

NOTE: The PR number of 54300 is wrong; but, it is still the best thing to search on.
	PR rtl-optimization/54300
	* regcprop.c (copyprop_hardreg_forward_1): Ensure any unused
	outputs in a single-set are killed from the value chains.
---
 gcc/regcprop.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/gcc/regcprop.c b/gcc/regcprop.c
index 0f0dfb3ce78..aed5b941fee 100644
--- a/gcc/regcprop.c
+++ b/gcc/regcprop.c
@@ -741,6 +741,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)
       int n_ops, i, alt, predicated;
       bool is_asm, any_replacements;
       rtx set;
+      rtx link;
       bool replaced[MAX_RECOG_OPERANDS];
       bool changed = false;
 
@@ -808,6 +809,23 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)
 	if (recog_op_alt[i][alt].earlyclobber)
 	  kill_value (recog_data.operand[i], vd);
 
+      /* If we have dead sets in the insn, then we need to note these as we
+	 would clobbers.  */
+      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))
+	{
+	  if (REG_NOTE_KIND (link) == REG_UNUSED)
+	    {
+	      kill_value (XEXP (link, 0), vd);
+	      /* Furthermore, if the insn looked like a single-set,
+		 but the dead store kills the source value of that
+		 set, then we can no-longer use the plain move
+		 special case below.  */
+	      if (set
+		  && reg_overlap_mentioned_p (XEXP (link, 0), SET_SRC (set)))
+		set = NULL;
+	    }
+	}
+
       /* Special-case plain move instructions, since we may well
 	 be able to do the move from a different register class.  */
       if (set && REG_P (SET_SRC (set)))
-- 
